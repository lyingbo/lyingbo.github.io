<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>NoName 技术专栏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="NoName 技术专栏">
<meta property="og:url" content="http://lyingbo.com/index.html">
<meta property="og:site_name" content="NoName 技术专栏">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NoName 技术专栏">
  
    <link rel="alternate" href="/atom.xml" title="NoName 技术专栏" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">NoName 技术专栏</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术积累及分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://lyingbo.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-基于OpenDDS应用程序开发(3)订阅端实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/03/基于OpenDDS应用程序开发(3)订阅端实现/" class="article-date">
  <time datetime="2019-09-02T16:00:00.000Z" itemprop="datePublished">2019-09-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/09/03/基于OpenDDS应用程序开发(3)订阅端实现/">基于OpenDDS应用程序开发(3)订阅端实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>连续的三篇博文演示如何基于OpenDDS开发应用程序，将数据从发布端节点发送到订阅端节点，该示例程序由一个发布者发布数据，一个订阅者订阅数据，使用默认的QoS策略和TCP/IP传输方式。</p>
<p>本文是第三篇，主要介绍开发一个简单的OpenDDS订阅端应用程序所涉及的步骤。省略一些不重要部分(如:#include部分和异常处理等)代码，只写出关键代码。</p>
<h2 id="新建订阅端工程"><a href="#新建订阅端工程" class="headerlink" title="新建订阅端工程"></a>新建订阅端工程</h2><p>参考前一博文中MPC的用法，在Demo.mpc文件中增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> project(*Subscriber) : dcpsexe_with_tcp &#123;</span><br><span class="line"></span><br><span class="line"> exename   = subscriber</span><br><span class="line"> after   += *idl</span><br><span class="line"></span><br><span class="line"> TypeSupport_Files &#123;</span><br><span class="line">   Demo.idl</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Source_Files &#123;</span><br><span class="line">   Subscriber.cpp</span><br><span class="line">   DataReaderListenerImpl.cpp</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Subscriber工程从父工程dcpsexe_with_tcp继承，这里直接使用idl工程中定义好的Demo.idl文件。</p>
<p>之后在Demo目录下新建三个文件：Subscriber.cpp、DataReaderListenerImpl.h、DataReaderListenerImpl.cpp，分别用来编写订阅端逻辑部分代码，并再次使用如下命令来生成Vs2008工程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mwc.pl  -type  vc9</span><br></pre></td></tr></table></figure>

<p>生成完成之后，使用Vs2008打开Demo.sln，就可以修改订阅端代码了：</p>
<h2 id="初始化参与者"><a href="#初始化参与者" class="headerlink" title="初始化参与者"></a>初始化参与者</h2><p>初始化订阅端参与者代码同发布端是完全一样的，在Subscriber.cpp文件中增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main (int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">  </span><br><span class="line">   DDS::DomainParticipantFactory_var dpf =</span><br><span class="line">     TheParticipantFactoryWithArgs(argc, argv);</span><br><span class="line"></span><br><span class="line">   DDS::DomainParticipant_var participant =</span><br><span class="line">     dpf-&gt;create_participant(42, // Domain ID</span><br><span class="line">                         PARTICIPANT_QOS_DEFAULT,</span><br><span class="line">                         0,  // No listener required</span><br><span class="line">                         OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">   if (!participant) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;create_participant failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return 1 ;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="注册数据类型并创建主题"><a href="#注册数据类型并创建主题" class="headerlink" title="注册数据类型并创建主题"></a>注册数据类型并创建主题</h2><p>接下来，初始化数据类型和主题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Demo::PosTypeSupport_var mts = new Demo::PosTypeSupportImpl();</span><br><span class="line">if (DDS::RETCODE_OK != mts-&gt;register_type(participant, &quot;&quot;)) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed to register the PosTypeSupport.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CORBA::String_var type_name = mts-&gt;get_type_name();</span><br><span class="line">DDS::Topic_var topic =</span><br><span class="line">  participant-&gt;create_topic(&quot;Pos Demo&quot;,</span><br><span class="line">                        type_name,</span><br><span class="line">                        TOPIC_QOS_DEFAULT,</span><br><span class="line">                        0,   // No listener required</span><br><span class="line">                        OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!topic) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed to create_topic.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建订阅者"><a href="#创建订阅者" class="headerlink" title="创建订阅者"></a>创建订阅者</h2><p>调用create_subscriber()操作创建一个带有默认QoS策略的订阅者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DDS::Subscriber_var sub =</span><br><span class="line">  participant-&gt;create_subscriber(SUBSCRIBER_QOS_DEFAULT,</span><br><span class="line">                            0,  // No listener required</span><br><span class="line">                            OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!sub) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed to create_subscriber.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建数据读者及监听者"><a href="#创建数据读者及监听者" class="headerlink" title="创建数据读者及监听者"></a>创建数据读者及监听者</h2><p>订阅端需要给数据读者关联一个监听者，用来接收数据的到达，下面的代码定义了一个监听者对象，类DataReaderListenerImpl的实现将在下一部分介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DDS::DataReaderListener_var listener(new DataReaderListenerImpl);</span><br></pre></td></tr></table></figure>

<p>现在采用默认的QoS策略创建数据读者，并将它与主题、刚刚创建的监听者对象相关联起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DDS::DataReader_var dr =</span><br><span class="line">  sub-&gt;create_datareader(topic,</span><br><span class="line">                     DATAREADER_QOS_DEFAULT,</span><br><span class="line">                     listener,</span><br><span class="line">                     OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!dr) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;create_datareader failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，主线程就可以自由的去处理其它工作了，当有数据到达时，OpenDDS会调用监听者对象的回调接口通知，只需要在DataReaderListenerImpl类的回调函数中接收需要的数据就可以了。</p>
<h2 id="数据读者监听者实现"><a href="#数据读者监听者实现" class="headerlink" title="数据读者监听者实现"></a>数据读者监听者实现</h2><p>监听者类继承自DDS规范的DDS::DataReaderListener接口，该接口定义了一些回调函数，每个回调函数被调用时，就是一个事件的通知，如：断开、重连等，以下是DataReaderListener接口的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module DDS &#123;</span><br><span class="line"></span><br><span class="line"> local interface DataReaderListener : Listener &#123;</span><br><span class="line"></span><br><span class="line">   void on_requested_deadline_missed(in DataReader reader,</span><br><span class="line">                                 in RequestedDeadlineMissedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_requested_incompatible_qos(in DataReader reader,</span><br><span class="line">                                 in RequestedIncompatibleQosStatus status);</span><br><span class="line"></span><br><span class="line">   void on_sample_rejected(in DataReader reader,</span><br><span class="line">                        in SampleRejectedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_liveliness_changed(in DataReader reader,</span><br><span class="line">                          in LivelinessChangedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_data_available(in DataReader reader);</span><br><span class="line"></span><br><span class="line">   void on_subscription_matched(in DataReader reader,</span><br><span class="line">                            in SubscriptionMatchedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_sample_lost(in DataReader reader, in SampleLostStatus status);</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在本例的DataReaderListenerImpl类中真正需要的实现的回调接口是on_data_available()，它也是我们需要重新派生该类的唯一成员函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void DataReaderListenerImpl::on_data_available(DDS::DataReader_ptr reader) &#123;</span><br><span class="line"></span><br><span class="line"> num_reads_ ++;</span><br><span class="line"></span><br><span class="line"> try&#123;</span><br><span class="line"></span><br><span class="line">   Demo::PosDataReader_var reader_i = Demo::PosDataReader::_narrow(reader);</span><br><span class="line">   if (!reader_i) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;read: _narrow failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Demo::Pos pos;</span><br><span class="line">   DDS::SampleInfo si ;</span><br><span class="line">   DDS::ReturnCode_t status = reader_i-&gt;take_next_sample(pos, si) ;</span><br><span class="line">   if (status == DDS::RETCODE_OK) &#123;</span><br><span class="line">   </span><br><span class="line">     if (si.valid_data == 1) &#123;</span><br><span class="line">       std::cout &lt;&lt; &quot; Pos:pos_id = &quot; &lt;&lt; pos. pos_id &lt;&lt; std::endl</span><br><span class="line">                 &lt;&lt; &quot;  pos_x = &quot; &lt;&lt; pos. pos_x &lt;&lt; std::endl</span><br><span class="line">                 &lt;&lt; &quot;  pos_y = &quot; &lt;&lt; pos. pos_y &lt;&lt; std::endl;</span><br><span class="line">     &#125; else if (si.instance_state == DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE) &#123;</span><br><span class="line">       std::cout &lt;&lt; &quot;instance is disposed&quot; &lt;&lt; std::endl;</span><br><span class="line">     &#125; else if (si.instance_state == DDS::NOT_ALIVE_NO_WRITERS_INSTANCE_STATE) &#123;</span><br><span class="line">       std::cout &lt;&lt; &quot;instance is unregistered&quot; &lt;&lt; std::endl;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       std::cerr &lt;&lt; &quot;ERROR: received unknown instance state &quot;</span><br><span class="line">               &lt;&lt; si.instance_state &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line">	 </span><br><span class="line">   &#125; else if (status == DDS::RETCODE_NO_DATA) &#123;</span><br><span class="line">       cerr &lt;&lt; &quot;ERROR: reader received DDS::RETCODE_NO_DATA!&quot; &lt;&lt; std::endl;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       cerr &lt;&lt; &quot;ERROR: read Pos: Error: &quot; &lt;&lt;  status &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将样本从数据读者中取出，如果成功并能返回有效数据，就打印出接收到数据的每一个字段。</p>
<p>每当有样本数据到达时，该函数就会被调用。</p>
<h2 id="实体清理"><a href="#实体清理" class="headerlink" title="实体清理"></a>实体清理</h2><p>在订阅完数据以后，需要清理与OpenDDS相关联的资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">participant-&gt;delete_contained_entities();</span><br><span class="line">dpf-&gt;delete_participant(participant);</span><br><span class="line">TheServiceParticipant-&gt;shutdown ();</span><br></pre></td></tr></table></figure>

<p>调用域参与者的delete_contained_entities()操作删除所有该参与者创建的主题、订阅者。一旦执行完该操作，就可以使用域参与者工厂删除域参与者了。</p>
<h2 id="示例程序运行"><a href="#示例程序运行" class="headerlink" title="示例程序运行"></a>示例程序运行</h2><p>修改完以上代码并编译完成，就可以运行订阅端应用程序了，需要先运行DDS的信息仓库，开始中打开一个CMD窗口，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%DDS_ROOT%/bin/DCPSInfoRepo -ORBEndpoint iiop://localhost:12345</span><br></pre></td></tr></table></figure>

<p>再次打开一个CMD窗口，cd到Demo目录下，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscriber -DCPSInfoRepo corbaloc::localhost:12345/DCPSInfoRepo</span><br></pre></td></tr></table></figure>

<p>至此，订阅端应用程序就开发完成并运行起来了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2019/09/03/基于OpenDDS应用程序开发(3)订阅端实现/" data-id="ck0gj591s000477dx9ks0a11z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于OpenDDS应用程序开发(2)公布端实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/27/基于OpenDDS应用程序开发(2)公布端实现/" class="article-date">
  <time datetime="2019-08-26T16:00:00.000Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/27/基于OpenDDS应用程序开发(2)公布端实现/">基于OpenDDS应用程序开发(2)公布端实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>连续的三篇博文演示如何基于OpenDDS开发应用程序，将数据从发布端节点发送到订阅端节点，该示例程序由一个发布者发布数据，一个订阅者订阅数据，使用默认的QoS策略和TCP/IP传输方式。</p>
<p>本文是第二篇，主要介绍开发一个简单的OpenDDS公布端应用程序所涉及的步骤，省略一些不重要部分(如:#include部分和异常处理等)代码，只写出关键代码。</p>
<h2 id="新建公布端工程"><a href="#新建公布端工程" class="headerlink" title="新建公布端工程"></a>新建公布端工程</h2><p>参考前一博文中MPC的用法，在Demo.mpc文件中增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">project(*Publisher) : dcpsexe_with_tcp &#123;</span><br><span class="line"></span><br><span class="line"> exename   = publisher</span><br><span class="line"> after   += *idl</span><br><span class="line"></span><br><span class="line"> TypeSupport_Files &#123;</span><br><span class="line">   Demo.idl</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Source_Files &#123;</span><br><span class="line">   Publisher.cpp</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Publisher工程从父工程dcpsexe_with_tcp继承，这里直接使用idl工程中定义好的Demo.idl文件，之后在Demo目录下新建一个Publisher.cpp文件，用来编写公布端逻辑部分代码，并再次使用如下命令来生成Vs2008工程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mwc.pl  -type  vc9</span><br></pre></td></tr></table></figure>

<p>生成完成之后，使用Vs2008打开Demo.sln就可以修改Publisher.cpp中的代码了：</p>
<h2 id="初始化参与者"><a href="#初始化参与者" class="headerlink" title="初始化参与者"></a>初始化参与者</h2><p>main()函数的第一部分是为当前进程初始化一个OpenDDS参与者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main (int argc, char *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">   DDS::DomainParticipantFactory_var dpf =</span><br><span class="line">     TheParticipantFactoryWithArgs(argc, argv);</span><br><span class="line"></span><br><span class="line">   DDS::DomainParticipant_var participant =</span><br><span class="line">     dpf-&gt;create_participant(42, // domain ID</span><br><span class="line">                         PARTICIPANT_QOS_DEFAULT,</span><br><span class="line">                          0,  // No listener required</span><br><span class="line">                          OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">   if (!participant) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;create_participant failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用宏TheParticipantFactoryWithArgs，使用命令行参数初始化参与者工厂，这些命令行参数用来初始化ORB服务。</p>
<p>调用create_participant()操作，使用默认的QoS策略，在域参与者工厂中注册一个域参与者，并指定域ID为42，使用DDS默认的状态掩码，确保所有在中间件中的相关通信状态改变都能传递到应用程序中，域ID可以是在0x0~0x7FFFFFFF范围内的任意值，返回域参与者对象的引用，用来注册待公布的数据类型。</p>
<h2 id="注册数据类型并创建主题"><a href="#注册数据类型并创建主题" class="headerlink" title="注册数据类型并创建主题"></a>注册数据类型并创建主题</h2><p>首先，new一个PosTypeSupportImpl对象，然后调用register_type()操作注册一个带有类型名称的类型，示例中，使用空的类型名称，DDS缺省会把PosTypeSupport接口标识符作为该类型的名称，当然，也可以使用像“Pos”这样的特定类型名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Demo::PosTypeSupport_var mts = new Demo::PosTypeSupportImpl();</span><br><span class="line"> if (DDS::RETCODE_OK != mts-&gt;register_type(participant, &quot;&quot;)) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;register_type failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，从类型支持对象中获得注册的类型名称，调用create_topic()操作来创建主题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CORBA::String_var type_name = mts-&gt;get_type_name();</span><br><span class="line"></span><br><span class="line">DDS::Topic_var topic =</span><br><span class="line">participant-&gt;create_topic (&quot;Pos Demo&quot;,</span><br><span class="line">                        type_name,</span><br><span class="line">                        TOPIC_QOS_DEFAULT,</span><br><span class="line">                        0,   // No listener required</span><br><span class="line">                        OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!topic) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;create_topic failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，创建了一个名称为“Pos Demo”，默认主题类型和默认QoS策略的主题，接下来再创建公布者。</p>
<h2 id="创建公布者"><a href="#创建公布者" class="headerlink" title="创建公布者"></a>创建公布者</h2><p>调用create_publisher()操作创建一个带有默认公布者QoS策略的公布者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DDS::Publisher_var pub =</span><br><span class="line">  participant-&gt;create_publisher(PUBLISHER_QOS_DEFAULT,</span><br><span class="line">                           0,   // No listener required</span><br><span class="line">                           OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!pub) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;create_publisher failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建数据写者"><a href="#创建数据写者" class="headerlink" title="创建数据写者"></a>创建数据写者</h2><p>有了公布者，再调用create_datawriter()操作创建一个数据写者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   DDS::DataWriter_var writer =</span><br><span class="line">     pub-&gt;create_datawriter(topic,</span><br><span class="line">                        DATAWRITER_QOS_DEFAULT,</span><br><span class="line">                        0,   // No listener required</span><br><span class="line">                        OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">   if (!writer) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;create_datawriter failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建数据写者的时候，使用已经创建好的主题，默认的QoS 策略和空的监听者。然后将数据写者引用转换为PosDataWriter对象引用，方便使用数据写者类中已经定义好的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo::PosDataWriter_var pos_writer = Demo::PosDataWriter::_narrow(writer);</span><br></pre></td></tr></table></figure>

<h2 id="公布数据"><a href="#公布数据" class="headerlink" title="公布数据"></a>公布数据</h2><p>创建好数据写者，就可以公布数据了，先初始化要公布的对象pos的各个字段，之后调用数据写者的write接口公布数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Demo::Pos pos;</span><br><span class="line">pos.pos_id = 99;</span><br><span class="line">pos. pos_x = 99;</span><br><span class="line">pos. pos_y = 99;</span><br><span class="line">for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">  DDS::ReturnCode_t error = pos_writer-&gt;write(pos, DDS::HANDLE_NIL);</span><br><span class="line">  ++pos.pos_id;</span><br><span class="line">  if (error != DDS::RETCODE_OK) &#123;</span><br><span class="line">    // Log or otherwise handle the error condition</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个循环，调用write()操作将样本数据发送给所有注册过该主题的订阅者。</p>
<h2 id="等待接收"><a href="#等待接收" class="headerlink" title="等待接收"></a>等待接收</h2><p>由于DDS中的数据公布和数据订阅是解耦的，数据不保证一定交付。如果公布端应用程序要求所有公布的数据必须全部交付，需要在公布端调用数据写者的wait_for_acknowledgements()操作，来使公布端应用程序一直等待，直到订阅端接收到所有已经公布的数据。要使wait_for_acknowledgements()操作有效，数据读者必须设置RELIABILITY QoS策略（是缺省值）为RELIABLE。</p>
<p>数据写者调用此操作，并绑定一个timeout值作为等待的超时时间。如下的代码演示了调用wait_for_acknowledgements()阻塞15s等待订阅端接收所有数据的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DDS::Duration_t shutdown_delay = &#123;15, 0&#125;;</span><br><span class="line"></span><br><span class="line">  DDS::ReturnCode_t result;</span><br><span class="line">  result = writer-&gt;wait_for_acknowledgments(shutdown_delay);</span><br><span class="line">  if( result != DDS::RETCODE_OK) &#123;</span><br><span class="line">   std::cerr &lt;&lt; &quot;Failed while waiting for acknowledgment of &quot;</span><br><span class="line">             &lt;&lt; &quot;data being received by subscriptions, some data &quot;</span><br><span class="line">             &lt;&lt; &quot;may not have been delivered.&quot; &lt;&lt; std::endl;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="实体清理"><a href="#实体清理" class="headerlink" title="实体清理"></a>实体清理</h2><p>在公布完数据以后，需要清理与OpenDDS相关联的资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">participant-&gt;delete_contained_entities();</span><br><span class="line">dpf-&gt;delete_participant(participant);</span><br><span class="line">TheServiceParticipant-&gt;shutdown ();</span><br></pre></td></tr></table></figure>

<p>调用域参与者的delete_contained_entities()操作删除所有该参与者创建的主题、公布者。一旦执行完该操作，就可以使用域参与者工厂删除域参与者了。</p>
<h2 id="示例程序运行"><a href="#示例程序运行" class="headerlink" title="示例程序运行"></a>示例程序运行</h2><p>修改完以上代码并编译完成，就可以运行公布端应用程序了，需要先运行DDS的信息仓库，开始中打开一个CMD窗口，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%DDS_ROOT%/bin/DCPSInfoRepo  -ORBEndpoint  iiop://localhost:12345</span><br></pre></td></tr></table></figure>

<p>再次打开一个CMD窗口，cd到Demo目录下，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publisher -DCPSInfoRepo  corbaloc::localhost:12345/DCPSInfoRepo</span><br></pre></td></tr></table></figure>

<p>至此，公布端应用程序就开发完成并运行起来了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2019/08/27/基于OpenDDS应用程序开发(2)公布端实现/" data-id="ck0gj591p000377dxeorhtoin" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于OpenDDS应用程序开发(1)IDL定义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/20/基于OpenDDS应用程序开发(1)IDL定义/" class="article-date">
  <time datetime="2019-08-19T16:00:00.000Z" itemprop="datePublished">2019-08-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/20/基于OpenDDS应用程序开发(1)IDL定义/">基于OpenDDS应用程序开发(1)IDL定义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>连续的三篇博文演示如何基于OpenDDS开发应用程序，将数据从发布端节点发送到订阅端节点，该示例程序由一个发布者发布数据，一个订阅者订阅数据，使用默认的QoS策略和TCP/IP传输方式。</p>
<p>本文是第一篇，主要介绍IDL的定义及编译。</p>
<h2 id="IDL定义"><a href="#IDL定义" class="headerlink" title="IDL定义"></a>IDL定义</h2><p>DDS中的数据类型需要通过IDL格式定义，OpenDDS使用#pragma关键字定义DDS传输和处理的数据类型。<br>这些数据类型再由tao_idl编译器和OpenDDS_idl编译器进行预编译出来，生成用于网络传输这些数据类型的代码。</p>
<p>下面是一个定义Demo数据类型的IDL文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module Demo &#123;</span><br><span class="line"></span><br><span class="line">#pragma DCPS_DATA_TYPE &quot;Demo::Pos&quot;</span><br><span class="line">#pragma DCPS_DATA_KEY &quot;Demo::Pos.pos_id&quot;</span><br><span class="line"></span><br><span class="line">    struct Pos &#123;</span><br><span class="line">        long pos_id;</span><br><span class="line">        long pos_x;</span><br><span class="line">        long pos_y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IDL文件使用DCPS_DATA_TYPE定义一个结构体数据类型，IDL语法要求每个类型定义必须以该关键字开头。OpenDDS规定数据类型必须为一个结构体，结构体中可包含标量类型（short、long、float等）、枚举类型、字符串、队列、数组、结构体、以及它们的组合。本例中在demo模块中定义了一个结构体pos。</p>
<p>使用DCPS_DATA_KEY定义一个数据类型的键，一种数据类型可以有0个或多个键，这些键用于区分同一个主题内的不同实体。每个键必须是数值型、枚举型、字符串或者这些类型的typedef。DCPS_DATA_KEY限定了作用域的数据类型以及成员名，成员名标识为该类型的键，多个键由多个DCPS_DATA_KEY指定。在上面的IDL定义中，指定了pos_id作为Demo::Pos的键。每个样本发布时带有一个唯一的pos_id值，这样就可以区分同一主题中的不同实例。由于使用了默认的QoS策略，随后带有相同pos_id值的样本就会替代先前的样本。</p>
<p>其它类型，如结构体、序列和数组不能直接用来做key，但是当结构体的成员或数组中的元素是数值型、枚举型或者字符串型时可以。</p>
<h2 id="IDL编译"><a href="#IDL编译" class="headerlink" title="IDL编译"></a>IDL编译</h2><p>IDL文件首先需要由tao_idl编译，以生成数据在网络上传输时打包解包的代码，该IDL编译器位于$ACE_ROOT/bin/目录下，运行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tao_idl Demo.idl</span><br></pre></td></tr></table></figure>

<p>该命令为每个IDL文件编译生成6个个文件，这6个文件的文件名均由原IDL文件名开头，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;filename&gt;C.cpp</span><br><span class="line">&lt;filename&gt;C.h</span><br><span class="line">&lt;filename&gt;C.inl</span><br><span class="line">&lt;filename&gt;S.cpp</span><br><span class="line">&lt;filename&gt;S.h</span><br><span class="line">&lt;filename&gt;S.inl</span><br></pre></td></tr></table></figure>

<p>进而，IDL文件还需要由opendds_idl编译，以生成OpenDDS需要打包和解包信息的序列化和键支持代码，及用于数据读者和写者类型支持代码，该IDL编译器位于$DDS_ROOT/bin/目录下，运行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opendds_idl Demo.idl</span><br></pre></td></tr></table></figure>

<p>该命令为每个IDL文件编译生成三个文件，这三个文件的文件名均由原IDL文件名开头，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;filename&gt;TypeSupport.idl</span><br><span class="line">&lt;filename&gt;TypeSupportImpl.h</span><br><span class="line">&lt;filename&gt;TypeSupportImpl.cpp</span><br></pre></td></tr></table></figure>

<p>会生成DemoTypeSupport.idl、DemoTypeSupportImpl.h和DemoTypeSupportImpl.cpp三个文件，生成的IDL文件中包括了PosTypeSupport, PosDataWriter 和PosDataReader的接口定义，这些特定的DDS类型接口将会在稍后注册数据类型，发布数据样本和接收数据样本时使用，而生成的cpp文件实现了这些接口。</p>
<p>生成的IDL文件还需要和原始的IDL一起，由tao_idl编译器再次编译，以便生成相应的接口框架，之后这些生成的实现文件需要和使用Pos类型的OpenDDS应用程序源码一起编译链接。</p>
<p>opendds_idl编译器提供了许多选项参数，用于配置代码生成，这些选项参数将在后续章节详细描述。</p>
<p>通常，我们不需要手动直接调用tao_idl或者opendds_idl来编译IDL文件，可以借助编译工具来完成，如果使用ACE的MPC(MakeProjectCreator)工具，通过继承dcps来配置，该过程将会很简单，如下是使用ACE的MPC工具来实现这个工作的步骤：</p>
<p>首先，需要编写一个Demo.mpc文件，在mpc文件中定义一个idl工程，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">project(*idl): dcps &#123;</span><br><span class="line"></span><br><span class="line">    // This project ensures the common components get built first.</span><br><span class="line">    TypeSupport_Files &#123;</span><br><span class="line">        Demo.idl</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    custom_only = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>idl工程从父工程dcps继承，父工程dcps中定义了类型支持的编译规则，TypeSupport_Files部分告诉MPC，使用opendds_idl编译器从Demo.idl中生成类型支持文件。</p>
<p>编写好mpc文件之后，就可以使用MPC命令来生成C/C++的编译配置文件了，(MPC工具可以生成很多种系统的编译工程，包括Windows的Visual Studio系列，Linux的Makefile等)，这里将Demo.idl文件和Demo.mpc文件放到Demo文件加下，使用如下命令来生成Vs2008的工程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl   mwc.pl  -type  vc9</span><br></pre></td></tr></table></figure>

<p>命令执行完成后，会生成对应的Vs2008工程文件，包括vcproj和sln等，使用Vs2008打开Demo.sln就可以编译前面定义的idl文件，生成DemoC.cpp和DemoTypeSupport.idl等文件了。</p>
<p>关于公布端和订阅端应用程序的开发请参见后续博文。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2019/08/20/基于OpenDDS应用程序开发(1)IDL定义/" data-id="ck0gj5915000177dxoytab1xj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-基于Docker搭建Hadoop集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/13/基于Docker搭建Hadoop集群/" class="article-date">
  <time datetime="2019-08-12T16:00:00.000Z" itemprop="datePublished">2019-08-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hadoop/">Hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/13/基于Docker搭建Hadoop集群/">基于Docker搭建Hadoop集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>将Hadoop打包到Docker镜像中，就可以快速的在单个机器上搭建Hadoop集群，这样可以方便新手测试和学习。</p>
<p>Hadoop的master和slave分别运行在不同的Docker容器中，其中NameNode、ResourceManager运行在hadoop-master容器中，DataNode、NodeManager运行在hadoop-slave容器中。NameNode和DataNode是Hadoop分布式文件系统HDFS的组件，负责储存输入以及输出数据，而ResourceManager和NodeManager是Hadoop集群资源管理系统YARN的组件，负责CPU和内存资源的调度。</p>
<p>接下来将以Ubuntu16.04为基镜像，介绍搭建Hadoop3.2.0伪分布式集群运行环境的步骤：</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><h3 id="A-3节点Hadoop集群搭建步骤"><a href="#A-3节点Hadoop集群搭建步骤" class="headerlink" title="A. 3节点Hadoop集群搭建步骤:"></a>A. 3节点Hadoop集群搭建步骤:</h3><h5 id="1-下载Docker镜像"><a href="#1-下载Docker镜像" class="headerlink" title="1. 下载Docker镜像"></a>1. 下载Docker镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull lyingbo/hadoop:3.2.0</span><br></pre></td></tr></table></figure>

<h5 id="2-下载shell脚本"><a href="#2-下载shell脚本" class="headerlink" title="2. 下载shell脚本"></a>2. 下载shell脚本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lyingbo/hadoop-cluster-docker.git</span><br></pre></td></tr></table></figure>

<h5 id="3-运行Docker容器"><a href="#3-运行Docker容器" class="headerlink" title="3. 运行Docker容器"></a>3. 运行Docker容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hadoop-cluster-docker</span><br><span class="line">sudo ./start-container.sh</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start hadoop-master container...</span><br><span class="line">start hadoop-slave1 container...</span><br><span class="line">start hadoop-slave2 container...</span><br><span class="line">root@hadoop-master:/#</span><br></pre></td></tr></table></figure>

<ul>
<li>启动了3个容器，1个master，2个slave</li>
<li>运行后就进入了hadoop-master容器的/root目录</li>
</ul>
<h5 id="4-启动hadoop集群"><a href="#4-启动hadoop集群" class="headerlink" title="4. 启动hadoop集群"></a>4. 启动hadoop集群</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Starting namenodes on [hadoop-master]</span><br><span class="line">hadoop-master: Warning: Permanently added &apos;hadoop-master,172.18.0.2&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">Starting datanodes</span><br><span class="line">hadoop-slave2: Warning: Permanently added &apos;hadoop-slave2,172.18.0.4&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">hadoop-slave1: Warning: Permanently added &apos;hadoop-slave1,172.18.0.3&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">Starting secondary namenodes [hadoop-master]</span><br><span class="line">Starting resourcemanager</span><br><span class="line">Starting nodemanagers</span><br></pre></td></tr></table></figure>

<h5 id="5-运行wordcount示例"><a href="#5-运行wordcount示例" class="headerlink" title="5. 运行wordcount示例"></a>5. 运行wordcount示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run-wordcount.sh</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">input file1.txt:</span><br><span class="line">Hello Docker</span><br><span class="line"></span><br><span class="line">input file2.txt:</span><br><span class="line">Hello Hadoop</span><br><span class="line"></span><br><span class="line">input file3.txt:</span><br><span class="line">Hello MapReduce</span><br><span class="line"></span><br><span class="line">wordcount output:</span><br><span class="line">Docker  1</span><br><span class="line">Hadoop  1</span><br><span class="line">Hello   3</span><br><span class="line">MapReduce       1</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h3 id="B-N节点Hadoop集群搭建步骤"><a href="#B-N节点Hadoop集群搭建步骤" class="headerlink" title="B. N节点Hadoop集群搭建步骤:"></a>B. N节点Hadoop集群搭建步骤:</h3><h5 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考A部分2.下载shell脚本</span><br></pre></td></tr></table></figure>

<h5 id="2-重新构建Docker镜像"><a href="#2-重新构建Docker镜像" class="headerlink" title="2. 重新构建Docker镜像"></a>2. 重新构建Docker镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./resize-cluster.sh 5</span><br></pre></td></tr></table></figure>

<ul>
<li>可以指定任意N(N&gt;1)</li>
</ul>
<h5 id="3-启动Docker容器"><a href="#3-启动Docker容器" class="headerlink" title="3. 启动Docker容器"></a>3. 启动Docker容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./start-container.sh 5</span><br></pre></td></tr></table></figure>

<ul>
<li>与前一步中的N保持一致。</li>
</ul>
<h5 id="4-运行Hadoop"><a href="#4-运行Hadoop" class="headerlink" title="4. 运行Hadoop"></a>4. 运行Hadoop</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考A部分4~6.启动Hadoop，并运行wordcount。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2019/08/13/基于Docker搭建Hadoop集群/" data-id="ck0gj590o000077dx4h7pb7mo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenDDS/">OpenDDS</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/03/基于OpenDDS应用程序开发(3)订阅端实现/">基于OpenDDS应用程序开发(3)订阅端实现</a>
          </li>
        
          <li>
            <a href="/2019/08/27/基于OpenDDS应用程序开发(2)公布端实现/">基于OpenDDS应用程序开发(2)公布端实现</a>
          </li>
        
          <li>
            <a href="/2019/08/20/基于OpenDDS应用程序开发(1)IDL定义/">基于OpenDDS应用程序开发(1)IDL定义</a>
          </li>
        
          <li>
            <a href="/2019/08/13/基于Docker搭建Hadoop集群/">基于Docker搭建Hadoop集群</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 lyingbo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>