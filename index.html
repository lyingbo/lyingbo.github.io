<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>NoName 技术专栏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="编程是一门技术,更加是一门艺术">
<meta name="keywords" content="Docker,Hadoop,OpenDDS,C++">
<meta property="og:type" content="website">
<meta property="og:title" content="NoName 技术专栏">
<meta property="og:url" content="http://lyingbo.com/index.html">
<meta property="og:site_name" content="NoName 技术专栏">
<meta property="og:description" content="编程是一门技术,更加是一门艺术">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NoName 技术专栏">
<meta name="twitter:description" content="编程是一门技术,更加是一门艺术">
  
    <link rel="alternate" href="/atom.xml" title="NoName 技术专栏" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">NoName 技术专栏</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术积累及分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://lyingbo.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-基于Docker搭建Hadoop集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/14/基于Docker搭建Hadoop集群/" class="article-date">
  <time datetime="2019-06-13T16:00:00.000Z" itemprop="datePublished">2019-06-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hadoop/">Hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/14/基于Docker搭建Hadoop集群/">基于Docker搭建Hadoop集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>将Hadoop打包到Docker镜像中，就可以快速的在单个机器上搭建Hadoop集群，这样可以方便新手测试和学习。</p>
<p>Hadoop的master和slave分别运行在不同的Docker容器中，其中NameNode、ResourceManager运行在hadoop-master容器中，DataNode、NodeManager运行在hadoop-slave容器中。NameNode和DataNode是Hadoop分布式文件系统HDFS的组件，负责储存输入以及输出数据，而ResourceManager和NodeManager是Hadoop集群资源管理系统YARN的组件，负责CPU和内存资源的调度。</p>
<p>接下来将以Ubuntu16.04为基镜像，介绍搭建Hadoop3.2.0伪分布式集群运行环境的步骤：</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><h3 id="A-3节点Hadoop集群搭建步骤"><a href="#A-3节点Hadoop集群搭建步骤" class="headerlink" title="A. 3节点Hadoop集群搭建步骤:"></a>A. 3节点Hadoop集群搭建步骤:</h3><h5 id="1-下载Docker镜像"><a href="#1-下载Docker镜像" class="headerlink" title="1. 下载Docker镜像"></a>1. 下载Docker镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull lyingbo/hadoop:3.2.0</span><br></pre></td></tr></table></figure>

<h5 id="2-下载shell脚本"><a href="#2-下载shell脚本" class="headerlink" title="2. 下载shell脚本"></a>2. 下载shell脚本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lyingbo/hadoop-cluster-docker.git</span><br></pre></td></tr></table></figure>

<h5 id="3-运行Docker容器"><a href="#3-运行Docker容器" class="headerlink" title="3. 运行Docker容器"></a>3. 运行Docker容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hadoop-cluster-docker</span><br><span class="line">sudo ./start-container.sh</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start hadoop-master container...</span><br><span class="line">start hadoop-slave1 container...</span><br><span class="line">start hadoop-slave2 container...</span><br><span class="line">root@hadoop-master:/#</span><br></pre></td></tr></table></figure>

<ul>
<li>启动了3个容器，1个master，2个slave</li>
<li>运行后就进入了hadoop-master容器的/root目录</li>
</ul>
<h5 id="4-启动hadoop集群"><a href="#4-启动hadoop集群" class="headerlink" title="4. 启动hadoop集群"></a>4. 启动hadoop集群</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Starting namenodes on [hadoop-master]</span><br><span class="line">hadoop-master: Warning: Permanently added &apos;hadoop-master,172.18.0.2&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">Starting datanodes</span><br><span class="line">hadoop-slave2: Warning: Permanently added &apos;hadoop-slave2,172.18.0.4&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">hadoop-slave1: Warning: Permanently added &apos;hadoop-slave1,172.18.0.3&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">Starting secondary namenodes [hadoop-master]</span><br><span class="line">Starting resourcemanager</span><br><span class="line">Starting nodemanagers</span><br></pre></td></tr></table></figure>

<h5 id="5-运行wordcount示例"><a href="#5-运行wordcount示例" class="headerlink" title="5. 运行wordcount示例"></a>5. 运行wordcount示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run-wordcount.sh</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">input file1.txt:</span><br><span class="line">Hello Docker</span><br><span class="line"></span><br><span class="line">input file2.txt:</span><br><span class="line">Hello Hadoop</span><br><span class="line"></span><br><span class="line">input file3.txt:</span><br><span class="line">Hello MapReduce</span><br><span class="line"></span><br><span class="line">wordcount output:</span><br><span class="line">Docker  1</span><br><span class="line">Hadoop  1</span><br><span class="line">Hello   3</span><br><span class="line">MapReduce       1</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h3 id="B-N节点Hadoop集群搭建步骤"><a href="#B-N节点Hadoop集群搭建步骤" class="headerlink" title="B. N节点Hadoop集群搭建步骤:"></a>B. N节点Hadoop集群搭建步骤:</h3><h5 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考A部分2.下载shell脚本</span><br></pre></td></tr></table></figure>

<h5 id="2-重新构建Docker镜像"><a href="#2-重新构建Docker镜像" class="headerlink" title="2. 重新构建Docker镜像"></a>2. 重新构建Docker镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./resize-cluster.sh 5</span><br></pre></td></tr></table></figure>

<ul>
<li>可以指定任意N(N&gt;1)</li>
</ul>
<h5 id="3-启动Docker容器"><a href="#3-启动Docker容器" class="headerlink" title="3. 启动Docker容器"></a>3. 启动Docker容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./start-container.sh 5</span><br></pre></td></tr></table></figure>

<ul>
<li>与前一步中的N保持一致。</li>
</ul>
<h5 id="4-运行Hadoop"><a href="#4-运行Hadoop" class="headerlink" title="4. 运行Hadoop"></a>4. 运行Hadoop</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考A部分4~6.启动Hadoop，并运行wordcount。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2019/06/14/基于Docker搭建Hadoop集群/" data-id="ck0npe6gk0001pxdxz2kcbnpd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cluster/">Cluster</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DataNode/">DataNode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NameNode/">NameNode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OpenDDS之Qos策略(1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/16/OpenDDS之Qos策略(1)/" class="article-date">
  <time datetime="2014-09-15T16:00:00.000Z" itemprop="datePublished">2014-09-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/16/OpenDDS之Qos策略(1)/">OpenDDS之Qos策略(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OpenDDS对DDS规范（<a href="http://www.omg.org/cgi-bin/doc?formal/07-01-01.pdf" target="_blank" rel="noopener">OMG Document formal/07-01-01</a>）定义的22种QoS策略全部支持。</p>
<p>应用程序通过参与者的QoS约束，来指定需要的行为，然后由DDS的服务决定如何实现这些行为，这些策略应用于所有DDS实体（主题、数据写者、数据读者、发布者、订阅者、域参与者），但不是所有的策略都适用于所有的实体类型。</p>
<p>发布者和订阅者通过RxO模式相匹配，订阅者请求一组策略，发布者提供一组QoS策略给潜在的订阅者，然后DDS试图将请求的策略和提供的策略相匹配，如果这些策略相匹配则将它们关联起来。</p>
<p>在前面的《<a href="https://lyingbo.github.io/categories/OpenDDS" target="_blank" rel="noopener">基于OpenDDS的应用程序开发</a>》博文中，我们采用了默认的QoS策略，接下来的几篇博文将详细介绍每个QoS策略的相关细节。</p>
<h2 id="Qos策略"><a href="#Qos策略" class="headerlink" title="Qos策略"></a>Qos策略</h2><p>每个策略都定义了自己的结构，每个实体都支持策略的一个子集，并且定义了一个由被支持的策略结构体所组成的QoS结构体，一个给定实体的可用策略集不会受到QoS结构体中包含的策略结构体的限制，例如，发布者的QoS结构体的IDL定义格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module DDS &#123;</span><br><span class="line"> struct PublisherQos &#123;</span><br><span class="line">   PresentationQosPolicy presentation;</span><br><span class="line">   PartitionQosPolicy partition;</span><br><span class="line">   GroupDataQosPolicy group_data;</span><br><span class="line">   EntityFactoryQosPolicy entity_factory;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>设置一个策略就像获得一个已经有默认值的结构体一样简单，并在必要的时候修改个别策略值，然后将QoS结构体应用到实体中（通常是在实体被建立的时候），后续的章节中将详细说明如何获取各个实体的缺省QoS值。</p>
<p>应用程序可以通过调用set_qos()操作来改变任意实体的QoS策略。如果该QoS策略变得不再兼容，则现有的连接将会移除，否则，如果该Qos策略变得兼容了，将会有新的连接添加。该改变将会通过相应的实体调用QoS更新操作通知DCPSInfoRepo，DCPSInfoRepo将会依据Qos策略规范来重新检测兼容性和关联性，如果兼容性检测失败，set_qos()调用将会返回错误，关联性检测将以移除现有的连接或增加新的连接为结果。</p>
<p>如果试图去改变一个不能改变的QoS策略，set_qos()操作将会返回DDS::RETCODE_IMMUTABLE_POLICY。可以改变的QoS策略有如下几个：USER_DATA,TOPIC_DATA,LIFESPAN,OWNERSHIP_STRENGTH,TIME_BASED_FILTER,ENTITY_FACTORY,WRITER_DATA_LIFECYCLE,READER_DATA_LIFECYCLE，它们不需要重新检测兼容性和关联性。QoS策略DEADLINE和LATENCY_BUDGET需要重新检测相容性，关联性不需要。QoS策略PARTITION恰好相反，只需重新检测关联性，对于兼容性则不需重新检测。</p>
<h2 id="默认Qos策略值"><a href="#默认Qos策略值" class="headerlink" title="默认Qos策略值"></a>默认Qos策略值</h2><p>应用程序获取实体的默认QoS策略，通过实例化该实体的一个对应的Qos结构体，然后调用实体工厂的get_default_entity_qos()操作将它获取回来（例如，对于发布者和订阅者，可以通过使用域参与者来获取默认QoS）。</p>
<p>下面的示例代码说明了对于发布者、订阅者、主题、域参与者、数据写者、数据读者如何获取默认QoS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// Get default Publisher QoS from a DomainParticipant:</span><br><span class="line">DDS::PublisherQos pub_qos;</span><br><span class="line">DDS::ReturnCode_t ret;</span><br><span class="line">ret = domain_participant-&gt;get_default_publisher_qos(pub_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default publisher QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get default Subscriber QoS from a DomainParticipant:</span><br><span class="line">DDS::SubscriberQos sub_qos;</span><br><span class="line">ret = domain_participant-&gt;get_default_subscriber_qos(sub_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default subscriber QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get default Topic QoS from a DomainParticipant:</span><br><span class="line">DDS::TopicQos topic_qos;</span><br><span class="line">ret = domain_participant-&gt;get_default_topic_qos(topic_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default topic QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get default DomainParticipant QoS from a DomainParticipantFactory:</span><br><span class="line">DDS::DomainParticipantQos dp_qos;</span><br><span class="line">ret = domain_participant_factory-&gt;get_default_participant_qos(dp_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default participant QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get default DataWriter QoS from a Publisher:</span><br><span class="line">DDS::DataWriterQos dw_qos;</span><br><span class="line">ret = pub-&gt;get_default_datawriter_qos(dw_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default data writer QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get default DataReader QoS from a Subscriber:</span><br><span class="line">DDS::DataReaderQos dr_qos;</span><br><span class="line">ret = pub-&gt;get_default_datareader_qos(dr_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default data reader QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的表格总结了在OpenDDS中用到的每一种实体类型的默认QoS策略。</p>
<p>表1、默认域参与者QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th align="center">成员</th>
<th align="right">默认值</th>
</tr>
</thead>
<tbody><tr>
<td>USER_DATA</td>
<td align="center">value</td>
<td align="right">(not set)</td>
</tr>
<tr>
<td>ENTITY_FACTORY</td>
<td align="center">autoenable_created_entities</td>
<td align="right">true</td>
</tr>
</tbody></table>
<p>表2、默认主题QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th align="center">成员</th>
<th align="right">默认值</th>
</tr>
</thead>
<tbody><tr>
<td>TOPIC_DATA</td>
<td align="center">value</td>
<td align="right">(not set)</td>
</tr>
<tr>
<td>DURABILITY</td>
<td align="center">kind</td>
<td align="right">VOLATILE_DURABILITY_QOS</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">service_cleanup_delay.sec</td>
<td align="right">DURATION_ZERO_SEC</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">service_cleanup_delay.nanosec</td>
<td align="right">DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">history_kind</td>
<td align="right">KEEP_LAST_HISTORY_QOS</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">history_depth</td>
<td align="right">1</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">max_samples</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">max_instances</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">max_samples_per_instance</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>DEADLINE</td>
<td align="center">period.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>DEADLINE</td>
<td align="center">period.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>LATENCY_BUDGET</td>
<td align="center">duration.sec</td>
<td align="right">DURATION_ZERO_SEC</td>
</tr>
<tr>
<td>LATENCY_BUDGET</td>
<td align="center">duration.nanosec</td>
<td align="right">DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td align="center">kind</td>
<td align="right">AUTOMATIC_LIVELINESS_QOS</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td align="center">lease_duration.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td align="center">lease_duration.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td align="center">kind</td>
<td align="right">BEST_EFFORT_RELIABILITY_QOS</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td align="center">max_blocking_time.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td align="center">max_blocking_time.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>DESTINATION_ORDER</td>
<td align="center">kind</td>
<td align="right">BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</td>
</tr>
<tr>
<td>HISTORY</td>
<td align="center">kind</td>
<td align="right">KEEP_LAST_HISTORY_QOS</td>
</tr>
<tr>
<td>HISTORY</td>
<td align="center">depth</td>
<td align="right">1</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td align="center">max_samples</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td align="center">max_instances</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td align="center">max_samples_per_instance</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>TRANSPORT_PRIORITY</td>
<td align="center">value</td>
<td align="right">0</td>
</tr>
<tr>
<td>LIFESPAN</td>
<td align="center">duration.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>LIFESPAN</td>
<td align="center">duration.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>OWNERSHIP</td>
<td align="center">kind</td>
<td align="right">SHARED_OWNERSHIP_QOS</td>
</tr>
</tbody></table>
<p>表3、默认发布者QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th align="center">成员</th>
<th align="right">默认值</th>
</tr>
</thead>
<tbody><tr>
<td>PRESENTATION</td>
<td align="center">access_scope</td>
<td align="right">INSTANCE_PRESENTATION_QOS</td>
</tr>
<tr>
<td>PRESENTATION</td>
<td align="center">coherent_access</td>
<td align="right">0</td>
</tr>
<tr>
<td>PRESENTATION</td>
<td align="center">ordered_access</td>
<td align="right">0</td>
</tr>
<tr>
<td>PARTITION</td>
<td align="center">name</td>
<td align="right">(empty sequence)</td>
</tr>
<tr>
<td>GROUP_DATA</td>
<td align="center">value</td>
<td align="right">(not set)</td>
</tr>
<tr>
<td>ENTITY_FACTORY</td>
<td align="center">autoenable_created_entities</td>
<td align="right">true</td>
</tr>
</tbody></table>
<p>表4、默认订阅者QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th align="center">成员</th>
<th align="right">默认值</th>
</tr>
</thead>
<tbody><tr>
<td>PRESENTATION</td>
<td align="center">access_scope</td>
<td align="right">INSTANCE_PRESENTATION_QOS</td>
</tr>
<tr>
<td>PRESENTATION</td>
<td align="center">coherent_access</td>
<td align="right">0</td>
</tr>
<tr>
<td>PRESENTATION</td>
<td align="center">ordered_access</td>
<td align="right">0</td>
</tr>
<tr>
<td>PARTITION</td>
<td align="center">name</td>
<td align="right">(empty sequence)</td>
</tr>
<tr>
<td>GROUP_DATA</td>
<td align="center">value</td>
<td align="right">(not set)</td>
</tr>
<tr>
<td>ENTITY_FACTORY</td>
<td align="center">autoenable_created_entities</td>
<td align="right">true</td>
</tr>
</tbody></table>
<p>表5、默认数据写者QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th align="center">成员</th>
<th align="right">默认值</th>
</tr>
</thead>
<tbody><tr>
<td>DESTINATION_ORDER</td>
<td align="center">kind</td>
<td align="right">BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</td>
</tr>
<tr>
<td>HISTORY</td>
<td align="center">kind</td>
<td align="right">KEEP_LAST_HISTORY_QOS</td>
</tr>
<tr>
<td>HISTORY</td>
<td align="center">depth</td>
<td align="right">1</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td align="center">max_samples</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td align="center">max_instances</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td align="center">max_samples_per_instance</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>TRANSPORT_PRIORITY</td>
<td align="center">value</td>
<td align="right">0</td>
</tr>
<tr>
<td>LIFESPAN</td>
<td align="center">duration.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>LIFESPAN</td>
<td align="center">duration.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>USER_DATA</td>
<td align="center">value</td>
<td align="right">(not set)</td>
</tr>
<tr>
<td>OWNERSHIP</td>
<td align="center">kind</td>
<td align="right">SHARED_OWNERSHIP_QOS</td>
</tr>
<tr>
<td>OWNERSHIP_STRENGTH</td>
<td align="center">value</td>
<td align="right">0</td>
</tr>
<tr>
<td>WRITER_DATA_LIFECYCLE</td>
<td align="center">autodispose_unregistered_instances</td>
<td align="right">1</td>
</tr>
<tr>
<td>DURABILITY</td>
<td align="center">kind</td>
<td align="right">VOLATILE_DURABILITY_QOS</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">service_cleanup_delay.sec</td>
<td align="right">DURATION_ZERO_SEC</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">service_cleanup_delay.nanosec</td>
<td align="right">DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">history_kind</td>
<td align="right">KEEP_LAST_HISTORY_QOS</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">history_depth</td>
<td align="right">1</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">max_samples</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">max_instances</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td align="center">max_samples_per_instance</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>DEADLINE</td>
<td align="center">period.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>DEADLINE</td>
<td align="center">period.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>LATENCY_BUDGET</td>
<td align="center">duration.sec</td>
<td align="right">DURATION_ZERO_SEC</td>
</tr>
<tr>
<td>LATENCY_BUDGET</td>
<td align="center">duration.nanosec</td>
<td align="right">DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td align="center">kind</td>
<td align="right">AUTOMATIC_LIVELINESS_QOS</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td align="center">lease_duration.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td align="center">lease_duration.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td align="center">kind</td>
<td align="right">RELIABLE_RELIABILITY_QOS</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td align="center">max_blocking_time.sec</td>
<td align="right">0</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td align="center">max_blocking_time.nanosec</td>
<td align="right">100000000 (100 ms)</td>
</tr>
</tbody></table>
<p>表6、默认数据读者QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th align="center">成员</th>
<th align="right">默认值</th>
</tr>
</thead>
<tbody><tr>
<td>DURABILITY</td>
<td align="center">kind</td>
<td align="right">VOLATILE_DURABILITY_QOS</td>
</tr>
<tr>
<td>DEADLINE</td>
<td align="center">period.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>DEADLINE</td>
<td align="center">period.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>LATENCY_BUDGET</td>
<td align="center">duration.sec</td>
<td align="right">DURATION_ZERO_SEC</td>
</tr>
<tr>
<td>LATENCY_BUDGET</td>
<td align="center">duration.nanosec</td>
<td align="right">DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td align="center">kind</td>
<td align="right">AUTOMATIC_LIVELINESS_QOS</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td align="center">lease_duration.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td align="center">lease_duration.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td align="center">kind</td>
<td align="right">BEST_EFFORT_RELIABILITY_QOS</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td align="center">max_blocking_time.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td align="center">max_blocking_time.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>DESTINATION_ORDER</td>
<td align="center">kind</td>
<td align="right">BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</td>
</tr>
<tr>
<td>HISTORY</td>
<td align="center">kind</td>
<td align="right">KEEP_LAST_HISTORY_QOS</td>
</tr>
<tr>
<td>HISTORY</td>
<td align="center">depth</td>
<td align="right">1</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td align="center">max_samples</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td align="center">max_instances</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td align="center">max_samples_per_instance</td>
<td align="right">LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>USER_DATA</td>
<td align="center">value</td>
<td align="right">(not set)</td>
</tr>
<tr>
<td>OWNERSHIP</td>
<td align="center">kind</td>
<td align="right">SHARED_OWNERSHIP_QOS</td>
</tr>
<tr>
<td>TIME_BASED_FILTER</td>
<td align="center">minimum_separation.sec</td>
<td align="right">DURATION_ZERO_SEC</td>
</tr>
<tr>
<td>TIME_BASED_FILTER</td>
<td align="center">minimum_separation.nanosec</td>
<td align="right">DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td>READER_DATA_LIFECYCLE</td>
<td align="center">autopurge_nowriter_samples_delay.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>READER_DATA_LIFECYCLE</td>
<td align="center">autopurge_nowriter_samples_delay.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>READER_DATA_LIFECYCLE</td>
<td align="center">autopurge_disposed_samples_delay.sec</td>
<td align="right">DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td>READER_DATA_LIFECYCLE</td>
<td align="center">autopurge_disposed_samples_delay.nanosec</td>
<td align="right">DURATION_INFINITY_NSEC</td>
</tr>
</tbody></table>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2014/09/16/OpenDDS之Qos策略(1)/" data-id="ck0npe6ht001lpxdx9dik1ew8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Qos/">Qos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/策略使用/">策略使用</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/策略说明/">策略说明</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基于OpenDDS应用程序开发(3)订阅端实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/29/基于OpenDDS应用程序开发(3)订阅端实现/" class="article-date">
  <time datetime="2014-07-28T16:00:00.000Z" itemprop="datePublished">2014-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/29/基于OpenDDS应用程序开发(3)订阅端实现/">基于OpenDDS应用程序开发(3)订阅端实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>连续的三篇博文演示如何基于OpenDDS开发应用程序，将数据从发布端节点发送到订阅端节点，该示例程序由一个发布者发布数据，一个订阅者订阅数据，使用默认的QoS策略和TCP/IP传输方式。</p>
<p>本文是第三篇，主要介绍开发一个简单的OpenDDS订阅端应用程序所涉及的步骤。省略一些不重要部分(如:#include部分和异常处理等)代码，只写出关键代码。</p>
<h2 id="1、新建订阅端工程："><a href="#1、新建订阅端工程：" class="headerlink" title="1、新建订阅端工程："></a>1、新建订阅端工程：</h2><p>参考前一博文中MPC的用法，在Demo.mpc文件中增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> project(*Subscriber) : dcpsexe_with_tcp &#123;</span><br><span class="line"></span><br><span class="line"> exename = subscriber</span><br><span class="line"> after += *idl</span><br><span class="line"></span><br><span class="line"> TypeSupport_Files &#123;</span><br><span class="line">   Demo.idl</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Source_Files &#123;</span><br><span class="line">   Subscriber.cpp</span><br><span class="line">   DataReaderListenerImpl.cpp</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Subscriber工程从父工程dcpsexe_with_tcp继承，这里直接使用idl工程中定义好的Demo.idl文件。</p>
<p>之后在Demo目录下新建三个文件：Subscriber.cpp、DataReaderListenerImpl.h、DataReaderListenerImpl.cpp，分别用来编写订阅端逻辑部分代码，并再次使用如下命令来生成Vs2008工程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mwc.pl -type vc9</span><br></pre></td></tr></table></figure>

<p>生成完成之后，使用Vs2008打开Demo.sln，就可以修改订阅端代码了：</p>
<h2 id="2、初始化参与者："><a href="#2、初始化参与者：" class="headerlink" title="2、初始化参与者："></a>2、初始化参与者：</h2><p>初始化订阅端参与者代码同发布端是完全一样的，在Subscriber.cpp文件中增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">  </span><br><span class="line">   DDS::DomainParticipantFactory_var dpf =</span><br><span class="line">     TheParticipantFactoryWithArgs(argc, argv);</span><br><span class="line"></span><br><span class="line">   DDS::DomainParticipant_var participant =</span><br><span class="line">     dpf-&gt;create_participant(42, // Domain ID</span><br><span class="line">                         PARTICIPANT_QOS_DEFAULT,</span><br><span class="line">                         0,  // No listener required</span><br><span class="line">                         OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">   if (!participant) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;create_participant failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return 1 ;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、注册数据类型并创建主题："><a href="#3、注册数据类型并创建主题：" class="headerlink" title="3、注册数据类型并创建主题："></a>3、注册数据类型并创建主题：</h2><p>接下来，初始化数据类型和主题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Demo::PosTypeSupport_var mts = new Demo::PosTypeSupportImpl();</span><br><span class="line">if (DDS::RETCODE_OK != mts-&gt;register_type(participant, &quot;&quot;)) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed to register the PosTypeSupport.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CORBA::String_var type_name = mts-&gt;get_type_name();</span><br><span class="line">DDS::Topic_var topic =</span><br><span class="line">  participant-&gt;create_topic(&quot;Pos Demo&quot;,</span><br><span class="line">                        type_name,</span><br><span class="line">                        TOPIC_QOS_DEFAULT,</span><br><span class="line">                        0,   // No listener required</span><br><span class="line">                        OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!topic) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed to create_topic.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、创建订阅者："><a href="#4、创建订阅者：" class="headerlink" title="4、创建订阅者："></a>4、创建订阅者：</h2><p>调用create_subscriber()操作创建一个带有默认QoS策略的订阅者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DDS::Subscriber_var sub =</span><br><span class="line">  participant-&gt;create_subscriber(SUBSCRIBER_QOS_DEFAULT,</span><br><span class="line">                            0,  // No listener required</span><br><span class="line">                            OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!sub) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed to create_subscriber.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、创建数据读者及监听者："><a href="#5、创建数据读者及监听者：" class="headerlink" title="5、创建数据读者及监听者："></a>5、创建数据读者及监听者：</h2><p>订阅端需要给数据读者关联一个监听者，用来接收数据的到达，下面的代码定义了一个监听者对象，类DataReaderListenerImpl的实现将在下一部分介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DDS::DataReaderListener_var listener(new DataReaderListenerImpl);</span><br></pre></td></tr></table></figure>

<p>现在采用默认的QoS策略创建数据读者，并将它与主题、刚刚创建的监听者对象相关联起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DDS::DataReader_var dr =</span><br><span class="line">  sub-&gt;create_datareader(topic,</span><br><span class="line">                     DATAREADER_QOS_DEFAULT,</span><br><span class="line">                     listener,</span><br><span class="line">                     OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!dr) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;create_datareader failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，主线程就可以自由的去处理其它工作了，当有数据到达时，OpenDDS会调用监听者对象的回调接口通知，只需要在DataReaderListenerImpl类的回调函数中接收需要的数据就可以了。</p>
<h2 id="6、数据读者监听者实现："><a href="#6、数据读者监听者实现：" class="headerlink" title="6、数据读者监听者实现："></a>6、数据读者监听者实现：</h2><p>监听者类继承自DDS规范的DDS::DataReaderListener接口，该接口定义了一些回调函数，每个回调函数被调用时，就是一个事件的通知，如：断开、重连等，以下是DataReaderListener接口的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module DDS &#123;</span><br><span class="line"></span><br><span class="line"> local interface DataReaderListener : Listener &#123;</span><br><span class="line"></span><br><span class="line">   void on_requested_deadline_missed(in DataReader reader,</span><br><span class="line">                                 in RequestedDeadlineMissedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_requested_incompatible_qos(in DataReader reader,</span><br><span class="line">                                 in RequestedIncompatibleQosStatus status);</span><br><span class="line"></span><br><span class="line">   void on_sample_rejected(in DataReader reader,</span><br><span class="line">                        in SampleRejectedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_liveliness_changed(in DataReader reader,</span><br><span class="line">                          in LivelinessChangedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_data_available(in DataReader reader);</span><br><span class="line"></span><br><span class="line">   void on_subscription_matched(in DataReader reader,</span><br><span class="line">                            in SubscriptionMatchedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_sample_lost(in DataReader reader, in SampleLostStatus status);</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在本例的DataReaderListenerImpl类中真正需要的实现的回调接口是on_data_available()，它也是我们需要重新派生该类的唯一成员函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void DataReaderListenerImpl::on_data_available(DDS::DataReader_ptr reader) &#123;</span><br><span class="line"></span><br><span class="line"> num_reads_ ++;</span><br><span class="line"></span><br><span class="line"> try&#123;</span><br><span class="line"></span><br><span class="line">   Demo::PosDataReader_var reader_i = Demo::PosDataReader::_narrow(reader);</span><br><span class="line">   if (!reader_i) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;read: _narrow failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Demo::Pos pos;</span><br><span class="line">   DDS::SampleInfo si ;</span><br><span class="line">   DDS::ReturnCode_t status = reader_i-&gt;take_next_sample(pos, si) ;</span><br><span class="line">   if (status == DDS::RETCODE_OK) &#123;</span><br><span class="line">   </span><br><span class="line">     if (si.valid_data == 1) &#123;</span><br><span class="line">       std::cout &lt;&lt; &quot; Pos:pos_id = &quot; &lt;&lt; pos. pos_id &lt;&lt; std::endl</span><br><span class="line">                 &lt;&lt; &quot;  pos_x = &quot; &lt;&lt; pos. pos_x &lt;&lt; std::endl</span><br><span class="line">                 &lt;&lt; &quot;  pos_y = &quot; &lt;&lt; pos. pos_y &lt;&lt; std::endl;</span><br><span class="line">     &#125; else if (si.instance_state == DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE) &#123;</span><br><span class="line">       std::cout &lt;&lt; &quot;instance is disposed&quot; &lt;&lt; std::endl;</span><br><span class="line">     &#125; else if (si.instance_state == DDS::NOT_ALIVE_NO_WRITERS_INSTANCE_STATE) &#123;</span><br><span class="line">       std::cout &lt;&lt; &quot;instance is unregistered&quot; &lt;&lt; std::endl;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       std::cerr &lt;&lt; &quot;ERROR: received unknown instance state &quot;</span><br><span class="line">               &lt;&lt; si.instance_state &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line">	 </span><br><span class="line">   &#125; else if (status == DDS::RETCODE_NO_DATA) &#123;</span><br><span class="line">       cerr &lt;&lt; &quot;ERROR: reader received DDS::RETCODE_NO_DATA!&quot; &lt;&lt; std::endl;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       cerr &lt;&lt; &quot;ERROR: read Pos: &quot; &lt;&lt; status &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将样本从数据读者中取出，如果成功并能返回有效数据，就打印出接收到数据的每一个字段。</p>
<p>每当有样本数据到达时，该函数就会被调用。</p>
<h2 id="7、实体清理："><a href="#7、实体清理：" class="headerlink" title="7、实体清理："></a>7、实体清理：</h2><p>在订阅完数据以后，需要清理与OpenDDS相关联的资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">participant-&gt;delete_contained_entities();</span><br><span class="line">dpf-&gt;delete_participant(participant);</span><br><span class="line">TheServiceParticipant-&gt;shutdown();</span><br></pre></td></tr></table></figure>

<p>调用域参与者的delete_contained_entities()操作删除所有该参与者创建的主题、订阅者。一旦执行完该操作，就可以使用域参与者工厂删除域参与者了。</p>
<h2 id="8、示例程序运行："><a href="#8、示例程序运行：" class="headerlink" title="8、示例程序运行："></a>8、示例程序运行：</h2><p>修改完以上代码并编译完成，就可以运行订阅端应用程序了，需要先运行DDS的信息仓库，开始中打开一个CMD窗口，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%DDS_ROOT%/bin/DCPSInfoRepo -ORBEndpoint iiop://localhost:12345</span><br></pre></td></tr></table></figure>

<p>再次打开一个CMD窗口，cd到Demo目录下，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscriber -DCPSInfoRepo corbaloc::localhost:12345/DCPSInfoRepo</span><br></pre></td></tr></table></figure>

<p>至此，订阅端应用程序就开发完成并运行起来了。</p>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2014/07/29/基于OpenDDS应用程序开发(3)订阅端实现/" data-id="ck0npe6gv0006pxdxlsz3dqbu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MPC/">MPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/示例开发/">示例开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/订阅数据/">订阅数据</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基于OpenDDS应用程序开发(2)公布端实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/10/基于OpenDDS应用程序开发(2)公布端实现/" class="article-date">
  <time datetime="2014-07-09T16:00:00.000Z" itemprop="datePublished">2014-07-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/10/基于OpenDDS应用程序开发(2)公布端实现/">基于OpenDDS应用程序开发(2)公布端实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>连续的三篇博文演示如何基于OpenDDS开发应用程序，将数据从发布端节点发送到订阅端节点，该示例程序由一个发布者发布数据，一个订阅者订阅数据，使用默认的QoS策略和TCP/IP传输方式。</p>
<p>本文是第二篇，主要介绍开发一个简单的OpenDDS公布端应用程序所涉及的步骤，省略一些不重要部分(如:#include部分和异常处理等)代码，只写出关键代码。</p>
<h2 id="1、新建公布端工程："><a href="#1、新建公布端工程：" class="headerlink" title="1、新建公布端工程："></a>1、新建公布端工程：</h2><p>参考前一博文中MPC的用法，在Demo.mpc文件中增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">project(*Publisher) : dcpsexe_with_tcp &#123;</span><br><span class="line"></span><br><span class="line"> exename = publisher</span><br><span class="line"> after += *idl</span><br><span class="line"></span><br><span class="line"> TypeSupport_Files &#123;</span><br><span class="line">   Demo.idl</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Source_Files &#123;</span><br><span class="line">   Publisher.cpp</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Publisher工程从父工程dcpsexe_with_tcp继承，这里直接使用idl工程中定义好的Demo.idl文件，之后在Demo目录下新建一个Publisher.cpp文件，用来编写公布端逻辑部分代码，并再次使用如下命令来生成Vs2008工程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mwc.pl -type vc9</span><br></pre></td></tr></table></figure>

<p>生成完成之后，使用Vs2008打开Demo.sln就可以修改Publisher.cpp中的代码了：</p>
<h2 id="2、初始化参与者："><a href="#2、初始化参与者：" class="headerlink" title="2、初始化参与者："></a>2、初始化参与者：</h2><p>main()函数的第一部分是为当前进程初始化一个OpenDDS参与者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">   DDS::DomainParticipantFactory_var dpf =</span><br><span class="line">     TheParticipantFactoryWithArgs(argc, argv);</span><br><span class="line"></span><br><span class="line">   DDS::DomainParticipant_var participant =</span><br><span class="line">     dpf-&gt;create_participant(42, // domain ID</span><br><span class="line">                         PARTICIPANT_QOS_DEFAULT,</span><br><span class="line">                         0,  // No listener required</span><br><span class="line">                         OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">   if (!participant) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;create_participant failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用宏TheParticipantFactoryWithArgs，使用命令行参数初始化参与者工厂，这些命令行参数用来初始化ORB服务。</p>
<p>调用create_participant()操作，使用默认的QoS策略，在域参与者工厂中注册一个域参与者，并指定域ID为42，使用DDS默认的状态掩码，确保所有在中间件中的相关通信状态改变都能传递到应用程序中，域ID可以是在0x0~0x7FFFFFFF范围内的任意值，返回域参与者对象的引用，用来注册待公布的数据类型。</p>
<h2 id="3、注册数据类型并创建主题："><a href="#3、注册数据类型并创建主题：" class="headerlink" title="3、注册数据类型并创建主题："></a>3、注册数据类型并创建主题：</h2><p>首先，new一个PosTypeSupportImpl对象，然后调用register_type()操作注册一个带有类型名称的类型，示例中，使用空的类型名称，DDS缺省会把PosTypeSupport接口标识符作为该类型的名称，当然，也可以使用像“Pos”这样的特定类型名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Demo::PosTypeSupport_var mts = new Demo::PosTypeSupportImpl();</span><br><span class="line"> if (DDS::RETCODE_OK != mts-&gt;register_type(participant, &quot;&quot;)) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;register_type failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，从类型支持对象中获得注册的类型名称，调用create_topic()操作来创建主题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CORBA::String_var type_name = mts-&gt;get_type_name();</span><br><span class="line"></span><br><span class="line">DDS::Topic_var topic =</span><br><span class="line">participant-&gt;create_topic(&quot;Pos Demo&quot;,</span><br><span class="line">                        type_name,</span><br><span class="line">                        TOPIC_QOS_DEFAULT,</span><br><span class="line">                        0,   // No listener required</span><br><span class="line">                        OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!topic) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;create_topic failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，创建了一个名称为“Pos Demo”，默认主题类型和默认QoS策略的主题，接下来再创建公布者。</p>
<h2 id="4、创建公布者："><a href="#4、创建公布者：" class="headerlink" title="4、创建公布者："></a>4、创建公布者：</h2><p>调用create_publisher()操作创建一个带有默认公布者QoS策略的公布者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DDS::Publisher_var pub =</span><br><span class="line">  participant-&gt;create_publisher(PUBLISHER_QOS_DEFAULT,</span><br><span class="line">                           0,   // No listener required</span><br><span class="line">                           OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!pub) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;create_publisher failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、创建数据写者："><a href="#5、创建数据写者：" class="headerlink" title="5、创建数据写者："></a>5、创建数据写者：</h2><p>有了公布者，再调用create_datawriter()操作创建一个数据写者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   DDS::DataWriter_var writer =</span><br><span class="line">     pub-&gt;create_datawriter(topic,</span><br><span class="line">                        DATAWRITER_QOS_DEFAULT,</span><br><span class="line">                        0,   // No listener required</span><br><span class="line">                        OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">   if (!writer) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;create_datawriter failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建数据写者的时候，使用已经创建好的主题，默认的QoS 策略和空的监听者。然后将数据写者引用转换为PosDataWriter对象引用，方便使用数据写者类中已经定义好的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo::PosDataWriter_var pos_writer = Demo::PosDataWriter::_narrow(writer);</span><br></pre></td></tr></table></figure>

<h2 id="6、公布数据："><a href="#6、公布数据：" class="headerlink" title="6、公布数据："></a>6、公布数据：</h2><p>创建好数据写者，就可以公布数据了，先初始化要公布的对象pos的各个字段，之后调用数据写者的write接口公布数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Demo::Pos pos;</span><br><span class="line">pos.pos_id = 99;</span><br><span class="line">pos. pos_x = 99;</span><br><span class="line">pos. pos_y = 99;</span><br><span class="line">for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">  DDS::ReturnCode_t error = pos_writer-&gt;write(pos, DDS::HANDLE_NIL);</span><br><span class="line">  ++pos.pos_id;</span><br><span class="line">  if (error != DDS::RETCODE_OK) &#123;</span><br><span class="line">    // Log or otherwise handle the error condition</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个循环，调用write()操作将样本数据发送给所有注册过该主题的订阅者。</p>
<h2 id="7、等待接收："><a href="#7、等待接收：" class="headerlink" title="7、等待接收："></a>7、等待接收：</h2><p>由于DDS中的数据公布和数据订阅是解耦的，数据不保证一定交付。如果公布端应用程序要求所有公布的数据必须全部交付，需要在公布端调用数据写者的wait_for_acknowledgements()操作，来使公布端应用程序一直等待，直到订阅端接收到所有已经公布的数据。要使wait_for_acknowledgements()操作有效，数据读者必须设置RELIABILITY QoS策略（是缺省值）为RELIABLE。</p>
<p>数据写者调用此操作，并绑定一个timeout值作为等待的超时时间。如下的代码演示了调用wait_for_acknowledgements()阻塞15s等待订阅端接收所有数据的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> DDS::Duration_t shutdown_delay = &#123;15, 0&#125;;</span><br><span class="line"></span><br><span class="line"> DDS::ReturnCode_t result;</span><br><span class="line"> result = writer-&gt;wait_for_acknowledgments(shutdown_delay);</span><br><span class="line"> if( result != DDS::RETCODE_OK) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed while waiting for acknowledgment of &quot;</span><br><span class="line">            &lt;&lt; &quot;data being received by subscriptions, some data &quot;</span><br><span class="line">            &lt;&lt; &quot;may not have been delivered.&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、实体清理："><a href="#8、实体清理：" class="headerlink" title="8、实体清理："></a>8、实体清理：</h2><p>在公布完数据以后，需要清理与OpenDDS相关联的资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">participant-&gt;delete_contained_entities();</span><br><span class="line">dpf-&gt;delete_participant(participant);</span><br><span class="line">TheServiceParticipant-&gt;shutdown();</span><br></pre></td></tr></table></figure>

<p>调用域参与者的delete_contained_entities()操作删除所有该参与者创建的主题、公布者。一旦执行完该操作，就可以使用域参与者工厂删除域参与者了。</p>
<h2 id="9、示例程序运行："><a href="#9、示例程序运行：" class="headerlink" title="9、示例程序运行："></a>9、示例程序运行：</h2><p>修改完以上代码并编译完成，就可以运行公布端应用程序了，需要先运行DDS的信息仓库，开始中打开一个CMD窗口，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%DDS_ROOT%/bin/DCPSInfoRepo  -ORBEndpoint  iiop://localhost:12345</span><br></pre></td></tr></table></figure>

<p>再次打开一个CMD窗口，cd到Demo目录下，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publisher -DCPSInfoRepo corbaloc::localhost:12345/DCPSInfoRepo</span><br></pre></td></tr></table></figure>

<p>至此，公布端应用程序就开发完成并运行起来了。</p>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2014/07/10/基于OpenDDS应用程序开发(2)公布端实现/" data-id="ck0npe6gt0005pxdxc4fnqqu8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MPC/">MPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/发布数据/">发布数据</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/示例开发/">示例开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基于OpenDDS应用程序开发(1)IDL定义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/02/基于OpenDDS应用程序开发(1)IDL定义/" class="article-date">
  <time datetime="2014-07-01T16:00:00.000Z" itemprop="datePublished">2014-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/02/基于OpenDDS应用程序开发(1)IDL定义/">基于OpenDDS应用程序开发(1)IDL定义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>连续的三篇博文演示如何基于OpenDDS开发应用程序，将数据从发布端节点发送到订阅端节点，该示例程序由一个发布者发布数据，一个订阅者订阅数据，使用默认的QoS策略和TCP/IP传输方式。</p>
<p>本文是第一篇，主要介绍IDL的定义及编译。</p>
<h2 id="1、IDL定义："><a href="#1、IDL定义：" class="headerlink" title="1、IDL定义："></a>1、IDL定义：</h2><p>DDS中的数据类型需要通过IDL格式定义，OpenDDS使用#pragma关键字定义DDS传输和处理的数据类型。<br>这些数据类型再由tao_idl编译器和OpenDDS_idl编译器进行预编译出来，生成用于网络传输这些数据类型的代码。</p>
<p>下面是一个定义Demo数据类型的IDL文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module Demo &#123;</span><br><span class="line"></span><br><span class="line">#pragma DCPS_DATA_TYPE &quot;Demo::Pos&quot;</span><br><span class="line">#pragma DCPS_DATA_KEY &quot;Demo::Pos.pos_id&quot;</span><br><span class="line"></span><br><span class="line">    struct Pos &#123;</span><br><span class="line">        long pos_id;</span><br><span class="line">        long pos_x;</span><br><span class="line">        long pos_y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IDL文件使用DCPS_DATA_TYPE定义一个结构体数据类型，IDL语法要求每个类型定义必须以该关键字开头。OpenDDS规定数据类型必须为一个结构体，结构体中可包含标量类型（short、long、float等）、枚举类型、字符串、队列、数组、结构体、以及它们的组合。本例中在demo模块中定义了一个结构体pos。</p>
<p>使用DCPS_DATA_KEY定义一个数据类型的键，一种数据类型可以有0个或多个键，这些键用于区分同一个主题内的不同实体。每个键必须是数值型、枚举型、字符串或者这些类型的typedef。DCPS_DATA_KEY限定了作用域的数据类型以及成员名，成员名标识为该类型的键，多个键由多个DCPS_DATA_KEY指定。在上面的IDL定义中，指定了pos_id作为Demo::Pos的键。每个样本发布时带有一个唯一的pos_id值，这样就可以区分同一主题中的不同实例。由于使用了默认的QoS策略，随后带有相同pos_id值的样本就会替代先前的样本。</p>
<p>其它类型，如结构体、序列和数组不能直接用来做key，但是当结构体的成员或数组中的元素是数值型、枚举型或者字符串型时可以。</p>
<h2 id="2、IDL编译："><a href="#2、IDL编译：" class="headerlink" title="2、IDL编译："></a>2、IDL编译：</h2><p>IDL文件首先需要由tao_idl编译，以生成数据在网络上传输时打包解包的代码，该IDL编译器位于$ACE_ROOT/bin/目录下，运行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tao_idl Demo.idl</span><br></pre></td></tr></table></figure>

<p>该命令为每个IDL文件编译生成6个个文件，这6个文件的文件名均由原IDL文件名开头，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;filename&gt;C.cpp</span><br><span class="line">&lt;filename&gt;C.h</span><br><span class="line">&lt;filename&gt;C.inl</span><br><span class="line">&lt;filename&gt;S.cpp</span><br><span class="line">&lt;filename&gt;S.h</span><br><span class="line">&lt;filename&gt;S.inl</span><br></pre></td></tr></table></figure>

<p>进而，IDL文件还需要由opendds_idl编译，以生成OpenDDS需要打包和解包信息的序列化和键支持代码，及用于数据读者和写者类型支持代码，该IDL编译器位于$DDS_ROOT/bin/目录下，运行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opendds_idl Demo.idl</span><br></pre></td></tr></table></figure>

<p>该命令为每个IDL文件编译生成三个文件，这三个文件的文件名均由原IDL文件名开头，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;filename&gt;TypeSupport.idl</span><br><span class="line">&lt;filename&gt;TypeSupportImpl.h</span><br><span class="line">&lt;filename&gt;TypeSupportImpl.cpp</span><br></pre></td></tr></table></figure>

<p>会生成DemoTypeSupport.idl、DemoTypeSupportImpl.h和DemoTypeSupportImpl.cpp三个文件，生成的IDL文件中包括了PosTypeSupport, PosDataWriter 和PosDataReader的接口定义，这些特定的DDS类型接口将会在稍后注册数据类型，发布数据样本和接收数据样本时使用，而生成的cpp文件实现了这些接口。</p>
<p>生成的IDL文件还需要和原始的IDL一起，由tao_idl编译器再次编译，以便生成相应的接口框架，之后这些生成的实现文件需要和使用Pos类型的OpenDDS应用程序源码一起编译链接。</p>
<p>opendds_idl编译器提供了许多选项参数，用于配置代码生成，这些选项参数将在后续章节详细描述。</p>
<p>通常，我们不需要手动直接调用tao_idl或者opendds_idl来编译IDL文件，可以借助编译工具来完成，如果使用ACE的MPC(MakeProjectCreator)工具，通过继承dcps来配置，该过程将会很简单，如下是使用ACE的MPC工具来实现这个工作的步骤：</p>
<p>首先，需要编写一个Demo.mpc文件，在mpc文件中定义一个idl工程，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">project(*idl): dcps &#123;</span><br><span class="line"></span><br><span class="line">    // This project ensures the common components get built first.</span><br><span class="line">    TypeSupport_Files &#123;</span><br><span class="line">        Demo.idl</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    custom_only = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>idl工程从父工程dcps继承，父工程dcps中定义了类型支持的编译规则，TypeSupport_Files部分告诉MPC，使用opendds_idl编译器从Demo.idl中生成类型支持文件。</p>
<p>编写好mpc文件之后，就可以使用MPC命令来生成C/C++的编译配置文件了，(MPC工具可以生成很多种系统的编译工程，包括Windows的Visual Studio系列，Linux的Makefile等)，这里将Demo.idl文件和Demo.mpc文件放到Demo文件加下，使用如下命令来生成Vs2008的工程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl mwc.pl -type vc9</span><br></pre></td></tr></table></figure>

<p>命令执行完成后，会生成对应的Vs2008工程文件，包括vcproj和sln等，使用Vs2008打开Demo.sln就可以编译前面定义的idl文件，生成DemoC.cpp和DemoTypeSupport.idl等文件了。</p>
<p>关于公布端和订阅端应用程序的开发请参见后续博文。</p>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2014/07/02/基于OpenDDS应用程序开发(1)IDL定义/" data-id="ck0npe6gr0004pxdxqm9aic4n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDL定义/">IDL定义</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDL编译/">IDL编译</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MPC/">MPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/示例开发/">示例开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OpenDDS环境搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/03/06/OpenDDS环境搭建/" class="article-date">
  <time datetime="2014-03-05T16:00:00.000Z" itemprop="datePublished">2014-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/03/06/OpenDDS环境搭建/">OpenDDS环境搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下以Linux系统下的用户DDS为例(关于Windows系统下的搭建过程，跟Linux系统步骤基本一样，请参考文后的评论)，编译OpenDDS源码需要ACE+TAO框架支持，因此需要先编译ACE+TAO的相关库，具体步骤如下：</p>
<h2 id="1、下载ACE和DDS源码："><a href="#1、下载ACE和DDS源码：" class="headerlink" title="1、下载ACE和DDS源码："></a>1、下载ACE和DDS源码：</h2><p>ACE源码：<a href="http://www.theaceorb.com/downloads" target="_blank" rel="noopener">http://www.theaceorb.com/downloads</a><br>DDS源码：<a href="http://download.ociweb.com/OpenDDS" target="_blank" rel="noopener">http://download.ociweb.com/OpenDDS</a></p>
<h2 id="2、拷贝源码包到-WorkSpace目录："><a href="#2、拷贝源码包到-WorkSpace目录：" class="headerlink" title="2、拷贝源码包到/WorkSpace目录："></a>2、拷贝源码包到/WorkSpace目录：</h2><p>切换到root用户，在根目下创建WorkSpace目录，为WorkSpace目录给所有用户添加+w权限(chmod +w)，再切回到原来的DDS用户，将下载的ACE和DDS源码拷贝到WorkSpace目录下并解压，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$cp ACE+TAO-2.2a.tar.gz /WorkSpace</span><br><span class="line">$cp OpenDDS3.5.tar.gz   /WorkSpace</span><br><span class="line">$cd /WorkSpace</span><br><span class="line">$tar –xzvf ACE+TAO-6.1.0.tar.gz</span><br><span class="line">$tar –xzvf OpenDDS3.5.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="3、配置ACE和DDS环境变量："><a href="#3、配置ACE和DDS环境变量：" class="headerlink" title="3、配置ACE和DDS环境变量："></a>3、配置ACE和DDS环境变量：</h2><p>在/home/DDS/.bashrc文件最后加入下面几行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export ACE_ROOT=/WorkSpace/ACE_wrappers</span><br><span class="line">export TAO_ROOT=$ACE_ROOT/TAO</span><br><span class="line">export DDS_ROOT=/WorkSpace/DDS</span><br><span class="line">export PATH=$ACE_ROOT/bin: $DDS_ROOT/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$ACE_ROOT/lib:$DDS_ROOT/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>使用source /home/DDS/.bashrc命令或者重新登陆终端使环境变量生效</p>
<h2 id="4、准备系统相关配置文件："><a href="#4、准备系统相关配置文件：" class="headerlink" title="4、准备系统相关配置文件："></a>4、准备系统相关配置文件：</h2><p>创建文件/WorkSpace/ACE_wrappers/ace/config.h，写入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ace/config-linux.h&quot;</span><br></pre></td></tr></table></figure>

<p>创建文件/WorkSpace/ACE_wrappers/include/makeinclude/platform_macros.GNU，写入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug=0</span><br><span class="line">include $(ACE_ROOT)/include/makeinclude/platform_linux.GNU</span><br></pre></td></tr></table></figure>

<h2 id="5、编译ACE和DDS源码："><a href="#5、编译ACE和DDS源码：" class="headerlink" title="5、编译ACE和DDS源码："></a>5、编译ACE和DDS源码：</h2><p>由于ACE+TAO以及DDS源码中提供了许多测试程序，如果所有源码都编译，将非常耗时，可以只编译ACE+TAO中会被DDS用到的部分，以及DDS的核心部分源码。如此，就需要手动重新生成makefile文件，这里可以借助ACE的MPC工具来完成，先在$DDS_ROOT目录下编写一个DDS_TAO_Simple.mwc文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">workspace &#123;</span><br><span class="line">  $(ACE_ROOT)/ace/ace.mpc</span><br><span class="line">  $(ACE_ROOT)/apps/gperf/src</span><br><span class="line">  $(TAO_ROOT)/TAO_IDL</span><br><span class="line">  $(TAO_ROOT)/tao/tao.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/AnyTypeCode/AnyTypeCode.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/Codeset/Codeset.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/IORTable/IORTable.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/PortableServer/PortableServer.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/IORManipulation/IORManipulation.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/ImR_Client/ImR_Client.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/PI/PI.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/CodecFactory/CodecFactory.mpc</span><br><span class="line">  $(TAO_ROOT)/orbsvcs/orbsvcs/Svc_Utils.mpc</span><br><span class="line">  dds</span><br><span class="line"></span><br><span class="line">  exclude &#123;</span><br><span class="line">    dds/DCPS/QOS_XML_Handler</span><br><span class="line">    DevGuideExamples</span><br><span class="line">    tools</span><br><span class="line">    java</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在$DDS_ROOT目录下使用mwc.pl -type gnuace DDS_TAO_Simple.mwc -include $DDS_ROOT/MPC/config命令就可以生成需要的makefile了。</p>
<p>之后执行(cd $DDS_ROOT; make clean &amp;&amp; make) 1&gt; make-dds.log 2&gt;make-dds-err.log命令完成ACE和DDS的编译，如果编译出错，可以查看log文件的编译过程，待脚本运行完成，整个OpenDDS的开发环境就搭建好了，可以用来进行基于OpenDDS的二次开发了。</p>
<p>如果需要运行DDS的测试程序，cd到测试程序源码目录使用make命令就可以编译执行了。</p>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2014/03/06/OpenDDS环境搭建/" data-id="ck0npe6ga0000pxdxr5v81ndh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACE/">ACE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MPC/">MPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TAO/">TAO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/环境搭建/">环境搭建</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenDDS/">OpenDDS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACE/">ACE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cluster/">Cluster</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataNode/">DataNode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDL定义/">IDL定义</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDL编译/">IDL编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MPC/">MPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NameNode/">NameNode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qos/">Qos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TAO/">TAO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/发布数据/">发布数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/示例开发/">示例开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/策略使用/">策略使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/策略说明/">策略说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/订阅数据/">订阅数据</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ACE/" style="font-size: 10px;">ACE</a> <a href="/tags/Cluster/" style="font-size: 10px;">Cluster</a> <a href="/tags/DataNode/" style="font-size: 10px;">DataNode</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/IDL定义/" style="font-size: 10px;">IDL定义</a> <a href="/tags/IDL编译/" style="font-size: 10px;">IDL编译</a> <a href="/tags/MPC/" style="font-size: 16.67px;">MPC</a> <a href="/tags/NameNode/" style="font-size: 10px;">NameNode</a> <a href="/tags/OpenDDS/" style="font-size: 20px;">OpenDDS</a> <a href="/tags/Qos/" style="font-size: 10px;">Qos</a> <a href="/tags/TAO/" style="font-size: 10px;">TAO</a> <a href="/tags/发布数据/" style="font-size: 10px;">发布数据</a> <a href="/tags/环境搭建/" style="font-size: 10px;">环境搭建</a> <a href="/tags/示例开发/" style="font-size: 13.33px;">示例开发</a> <a href="/tags/策略使用/" style="font-size: 10px;">策略使用</a> <a href="/tags/策略说明/" style="font-size: 10px;">策略说明</a> <a href="/tags/订阅数据/" style="font-size: 10px;">订阅数据</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/14/基于Docker搭建Hadoop集群/">基于Docker搭建Hadoop集群</a>
          </li>
        
          <li>
            <a href="/2014/09/16/OpenDDS之Qos策略(1)/">OpenDDS之Qos策略(1)</a>
          </li>
        
          <li>
            <a href="/2014/07/29/基于OpenDDS应用程序开发(3)订阅端实现/">基于OpenDDS应用程序开发(3)订阅端实现</a>
          </li>
        
          <li>
            <a href="/2014/07/10/基于OpenDDS应用程序开发(2)公布端实现/">基于OpenDDS应用程序开发(2)公布端实现</a>
          </li>
        
          <li>
            <a href="/2014/07/02/基于OpenDDS应用程序开发(1)IDL定义/">基于OpenDDS应用程序开发(1)IDL定义</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 lyingbo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>