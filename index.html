<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>NoName 技术专栏</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="编程是一门技术,更加是一门艺术">
<meta name="keywords" content="Docker,Hadoop,OpenDDS,C++">
<meta property="og:type" content="website">
<meta property="og:title" content="NoName 技术专栏">
<meta property="og:url" content="http://lyingbo.com/index.html">
<meta property="og:site_name" content="NoName 技术专栏">
<meta property="og:description" content="编程是一门技术,更加是一门艺术">
<meta property="og:locale" content="zh">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NoName 技术专栏">
<meta name="twitter:description" content="编程是一门技术,更加是一门艺术">
  
    <link rel="alternate" href="/atom.xml" title="NoName 技术专栏" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">NoName 技术专栏</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术积累及分享</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://lyingbo.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-基于Docker搭建Hadoop集群" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/14/基于Docker搭建Hadoop集群/" class="article-date">
  <time datetime="2019-06-13T16:00:00.000Z" itemprop="datePublished">2019-06-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Hadoop/">Hadoop</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/14/基于Docker搭建Hadoop集群/">基于Docker搭建Hadoop集群</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>将Hadoop打包到Docker镜像中，就可以快速的在单个机器上搭建Hadoop集群，这样可以方便新手测试和学习。</p>
<p>Hadoop的master和slave分别运行在不同的Docker容器中，其中NameNode、ResourceManager运行在hadoop-master容器中，DataNode、NodeManager运行在hadoop-slave容器中。NameNode和DataNode是Hadoop分布式文件系统HDFS的组件，负责储存输入以及输出数据，而ResourceManager和NodeManager是Hadoop集群资源管理系统YARN的组件，负责CPU和内存资源的调度。</p>
<p>接下来将以Ubuntu16.04为基镜像，介绍搭建Hadoop3.2.0伪分布式集群运行环境的步骤：</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2><h3 id="A-3节点Hadoop集群搭建步骤"><a href="#A-3节点Hadoop集群搭建步骤" class="headerlink" title="A. 3节点Hadoop集群搭建步骤:"></a>A. 3节点Hadoop集群搭建步骤:</h3><h5 id="1-下载Docker镜像"><a href="#1-下载Docker镜像" class="headerlink" title="1. 下载Docker镜像"></a>1. 下载Docker镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull lyingbo/hadoop:3.2.0</span><br></pre></td></tr></table></figure>

<h5 id="2-下载shell脚本"><a href="#2-下载shell脚本" class="headerlink" title="2. 下载shell脚本"></a>2. 下载shell脚本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lyingbo/hadoop-cluster-docker.git</span><br></pre></td></tr></table></figure>

<h5 id="3-运行Docker容器"><a href="#3-运行Docker容器" class="headerlink" title="3. 运行Docker容器"></a>3. 运行Docker容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd hadoop-cluster-docker</span><br><span class="line">sudo ./start-container.sh</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start hadoop-master container...</span><br><span class="line">start hadoop-slave1 container...</span><br><span class="line">start hadoop-slave2 container...</span><br><span class="line">root@hadoop-master:/#</span><br></pre></td></tr></table></figure>

<ul>
<li>启动了3个容器，1个master，2个slave</li>
<li>运行后就进入了hadoop-master容器的/root目录</li>
</ul>
<h5 id="4-启动hadoop集群"><a href="#4-启动hadoop集群" class="headerlink" title="4. 启动hadoop集群"></a>4. 启动hadoop集群</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Starting namenodes on [hadoop-master]</span><br><span class="line">hadoop-master: Warning: Permanently added &apos;hadoop-master,172.18.0.2&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">Starting datanodes</span><br><span class="line">hadoop-slave2: Warning: Permanently added &apos;hadoop-slave2,172.18.0.4&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">hadoop-slave1: Warning: Permanently added &apos;hadoop-slave1,172.18.0.3&apos; (ECDSA) to the list of known hosts.</span><br><span class="line">Starting secondary namenodes [hadoop-master]</span><br><span class="line">Starting resourcemanager</span><br><span class="line">Starting nodemanagers</span><br></pre></td></tr></table></figure>

<h5 id="5-运行wordcount示例"><a href="#5-运行wordcount示例" class="headerlink" title="5. 运行wordcount示例"></a>5. 运行wordcount示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run-wordcount.sh</span><br></pre></td></tr></table></figure>

<p><strong>运行结果:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">input file1.txt:</span><br><span class="line">Hello Docker</span><br><span class="line"></span><br><span class="line">input file2.txt:</span><br><span class="line">Hello Hadoop</span><br><span class="line"></span><br><span class="line">input file3.txt:</span><br><span class="line">Hello MapReduce</span><br><span class="line"></span><br><span class="line">wordcount output:</span><br><span class="line">Docker  1</span><br><span class="line">Hadoop  1</span><br><span class="line">Hello   3</span><br><span class="line">MapReduce       1</span><br></pre></td></tr></table></figure>

<h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h3 id="B-N节点Hadoop集群搭建步骤"><a href="#B-N节点Hadoop集群搭建步骤" class="headerlink" title="B. N节点Hadoop集群搭建步骤:"></a>B. N节点Hadoop集群搭建步骤:</h3><h5 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考A部分2.下载shell脚本</span><br></pre></td></tr></table></figure>

<h5 id="2-重新构建Docker镜像"><a href="#2-重新构建Docker镜像" class="headerlink" title="2. 重新构建Docker镜像"></a>2. 重新构建Docker镜像</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./resize-cluster.sh 5</span><br></pre></td></tr></table></figure>

<ul>
<li>可以指定任意N(N&gt;1)</li>
</ul>
<h5 id="3-启动Docker容器"><a href="#3-启动Docker容器" class="headerlink" title="3. 启动Docker容器"></a>3. 启动Docker容器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./start-container.sh 5</span><br></pre></td></tr></table></figure>

<ul>
<li>与前一步中的N保持一致。</li>
</ul>
<h5 id="4-运行Hadoop"><a href="#4-运行Hadoop" class="headerlink" title="4. 运行Hadoop"></a>4. 运行Hadoop</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参考A部分4~6.启动Hadoop，并运行wordcount。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2019/06/14/基于Docker搭建Hadoop集群/" data-id="ck0rt0asr00051ndxgs9bgvp3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cluster/">Cluster</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DataNode/">DataNode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Docker/">Docker</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NameNode/">NameNode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OpenDDS之Qos策略(3)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/20/OpenDDS之Qos策略(3)/" class="article-date">
  <time datetime="2016-03-19T16:00:00.000Z" itemprop="datePublished">2016-03-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/20/OpenDDS之Qos策略(3)/">OpenDDS之Qos策略(3)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>OpenDDS主要支持22种Qos，前一篇<a href="https://lyingbo.github.io/2015/11/23/OpenDDS%E4%B9%8BQos%E7%AD%96%E7%95%A5(2)" target="_blank" rel="noopener">OpenDDS之Qos策略(2)</a>已对前12种Qos的具体内容作了介绍，接下来介绍下这剩下的10种Qos的具体内容以及用法。</p>
<h2 id="13、TRANSPORT-PRIORITY"><a href="#13、TRANSPORT-PRIORITY" class="headerlink" title="13、TRANSPORT_PRIORITY"></a>13、TRANSPORT_PRIORITY</h2><p>TRANSPORT_PRIORITY策略主要应用于主题和数据写者实体，下面是TRANSPORT_PRIORITY QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct TransportPriorityQosPolicy &#123;</span><br><span class="line">  long value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>value的默认值是0。该策略用于指定传输层发送消息时采用的优先级，值越大，表示优先级越高。OpenDDS把优先级映射到线程的优先级和DiffServ码点值上。默认值为0表示发送消息时既不修改线程的优先级，也不修改DiffServ的码点值。</p>
<p>OpenDDS支持设置发送线程的传输优先级和接收线程的传输优先级。传输优先级从0到最大值线性地映射0（默认）到最大线程优先级。如果最低传输优先级不是0，也映射为线程的优先级0。如果优先级在系统上出现倒置（数值越大优先级越低），OpenDDS将从0开始的增加的优先级。优先级比最低优先级还小则映射为最低优先级；如果高于线程最大优先级，则映射为最高优先级。</p>
<p>在大部分操作系统中，只有进程调度器设置为允许时，才能修改线程的优先级。进程需要获得系统特权才能执行相应操作，在基于POSIX的系统中，系统调用sched_get_priority_min()和sched_get_priority_max()来检测系统的线程优先级范围。</p>
<p>在传输层支持的前提下，OpenDDS将试图设置数据写者用来发送数据的套接字的DiffServ码点值。如果网络硬件支持码点值，越高的码点将具有越高的优先级，默认值0映射为码点值0（默认的）。优先级值从1到63会映射为相应的码点值，更高的取值都映射为最高值值63。OpenDDS当前版本不支持在创建数据写者之后修改transport_priority策略值。</p>
<h2 id="14、LATENCY-BUDGET"><a href="#14、LATENCY-BUDGET" class="headerlink" title="14、LATENCY_BUDGET"></a>14、LATENCY_BUDGET</h2><p>LATENCY_BUDGET策略主要应用于主题，数据读者和数据写者实体，下面是LATENCY_BUDGET QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct LatencyBudgetQosPolicy &#123;</span><br><span class="line">  Duration_t duration;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员duration的默认值是0，表示延迟尽量小。该策略用来指示传输层发送样本的紧急程度。OpenDDS使用该值划分样本从发布者到订阅者之间的传输时间是否为不可接受的延迟间隔。目前，该策略仅适用于监视目的，若需要调节传输延迟可使用TRANSPORT_PRIORITY策略。数据写者仅使用duration做兼容性比较，如果该值为默认的0，所有向它请求的数据读者都认为是兼容的。</p>
<p>为了统计超过duration策略设置的延迟数据，额外增加了一个监听者扩展接口。OpenDDS::DCPS::DataReaderListener额外提供了一个通知操作，当样本接收后测量的传输时延大于LATENCY_BUDGET策略的duration时，将会触发该操作，下面是该操作方法的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct BudgetExceededStatus &#123;</span><br><span class="line">  long total_count;</span><br><span class="line">  long total_count_change;</span><br><span class="line">  DDS::InstanceHandle_t last_instance_handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void on_budget_exceeded&#123;</span><br><span class="line">  in DDS::DataReader reader,</span><br><span class="line">  in BudgetExceededStatus status</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要使用扩展的Listener回调，首先要从Listener实现中派生一个类，如下面代码段所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class DataReaderListenerImpl</span><br><span class="line">   : public virtual</span><br><span class="line">   OpenDDS::DCPS::LocalObject</span><br></pre></td></tr></table></figure>

<p>接下来需要为on_budget_exceeded()操作提供一个非空的实现。需要注意的是，还需要为下面的扩展操作至少也提供一个空的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">on_subscription_disconnected()</span><br><span class="line">on_subscription_reconnected()</span><br><span class="line">on_subscription_lost()</span><br><span class="line">on_connection_deleted()</span><br></pre></td></tr></table></figure>

<p>OpenDDS还通过数据读者的扩展接口，提供了延迟统计汇总的功能，该扩展接口在OpenDDS::DCPS模型中，其IDL定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct LatencyStatistics &#123;</span><br><span class="line">  GUID_t publication;</span><br><span class="line">  unsigned long n;</span><br><span class="line">  double maximum;</span><br><span class="line">  double minimum;</span><br><span class="line">  double mean;</span><br><span class="line">  double variance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">typedef sequence LatencyStatisticsSeq;</span><br><span class="line"></span><br><span class="line">local interface DataReaderEx : DDS::DataReader &#123;</span><br><span class="line"></span><br><span class="line">  // Obtain a sequence of statistics summaries.</span><br><span class="line">  void get_latency_stats( inout LatencyStatisticsSeq stats);</span><br><span class="line"></span><br><span class="line">  // Clear any intermediate statistical values.</span><br><span class="line">  void reset_latency_stats();</span><br><span class="line"></span><br><span class="line">  // Statistics gathering enable state.</span><br><span class="line">  attribute boolean statistics_enabled;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>为了活的统计信息，需要使用上述扩展接口。也可以通过对数据读者对象的指针类型做转换，然后直接调用相应的接口。参见下面的示例代码，假定reader已经通过调用create_datareader方法正确初始化了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DDS::DataReader_var reader = DDS::Subscriber::create_datareader();</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">// To start collecting new data.</span><br><span class="line">dynamic_cast(reader.in())-&gt;reset_latency_stats();</span><br><span class="line">dynamic_cast(reader.in())-&gt;statistics_enabled(true);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">// To collect data.</span><br><span class="line">OpenDDS::DCPS::LatencyStatisticsSeq stats;</span><br><span class="line">dynamic_cast(reader.in())-&gt;get_latency_stats(stats);</span><br><span class="line"></span><br><span class="line">for (unsigned long i = 0; i &lt; stats.length(); ++i) &#123;</span><br><span class="line">  std::cout &lt;&lt; &quot;stats[&quot; &lt;&lt; i &lt;&lt; &quot;]:&quot; &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot; n = &quot; &lt;&lt; stats[i].n &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot; max = &quot; &lt;&lt; stats[i].maximum &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot; min = &quot; &lt;&lt; stats[i].minimum &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot; mean = &quot; &lt;&lt; stats[i].mean &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; &quot; variance = &quot; &lt;&lt; stats[i].variance &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15、ENTITY-FACTORY"><a href="#15、ENTITY-FACTORY" class="headerlink" title="15、ENTITY_FACTORY"></a>15、ENTITY_FACTORY</h2><p>ENTITY_FACTORY策略控制实体创建时，是否可以自动激活，下面是关于ENTITY_FACTORY QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct EntityFactoryQosPolicy &#123;</span><br><span class="line">  boolean autoenable_created_entities;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该策略可以应用到像工厂一样为其其它实体服务的实体，并且控制这些被工厂创建的实体是否自动激活。该策略可以应用于域参与者工厂（域参与者的工厂）、域参与者（发布者，订阅者，主题的工厂）、发布者（数据写者的工厂）、订阅者（数据读者的工厂）。该策略的默认值是true，表示工厂实体创建的其它实体可自动激活。如果应用程序希望这些实体可以在需要的时候才激活，可以把该策略的autoenable_created_entities成员的值设为false，然后手动调用实体的enable()操作来手动激活该实体。</p>
<p>该策略的值可以在运行的时候修改，改变将只会影响那些在之后被创建的实体。</p>
<h2 id="16、PRESENTATION"><a href="#16、PRESENTATION" class="headerlink" title="16、PRESENTATION"></a>16、PRESENTATION</h2><p>PRESENTATION QoS策略控制当订阅者具有一组读者时数据样本的展示顺序。它将影响实例的变化和一定范围内实例的展示顺序。另外，该策略还引入了连续变化集合的概念，下面是PRESENTATION QoS的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum PresentationQosPolicyAccessScopeKind &#123;</span><br><span class="line">  INSTANCE_PRESENTATION_QOS,</span><br><span class="line">  TOPIC_PRESENTATION_QOS,</span><br><span class="line">  GROUP_PRESENTATION_QOS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct PresentationQosPolicy &#123;</span><br><span class="line">  PresentationQosPolicyAccessScopeKind access_scope;</span><br><span class="line">  boolean coherent_access;</span><br><span class="line">  boolean ordered_access;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实例改变的范围指的是在应用程序中可能涉及到的级别，分为以下几个：</p>
<ul>
<li>INSTANCE_PRESENTATION_QOS（默认值）表示实例变化之间是无关的。尽管可以设置coherent_access（连续访问）和ordered_access（顺序访问），但代表相应的操作为空，也就是说，设为这个级别后对订阅者没有影响。</li>
<li>TOPIC_PRESENTATION_QOS表示获取的实例变化只限于相同的读者或写者。</li>
<li>GROUP_PRESENTATION_QOS表示获取的实例变化限制在相同发布者或订阅者上的所有实例。</li>
</ul>
<p>coherent_access允许在一个实例上的一个或者多个改变关联合并为一个单个变化。如果数据读者没能完整的接收到所有的改变，那么相当于这些改变都是无效的。这个语义非常类似于传统关系数据库的事件处理。coherent_access的默认值为false。</p>
<p>ordered_access表示发布者发布的数据在读者上按顺序展示。它的效果在本质上和DESTINATION_ORDER策略很相似，不同的是，ordered_access允许数据的顺序与实例顺利无关。ordered_access的默认值为false。</p>
<p>注：该策略影响了订阅者获得样本的顺序和作用域，但是订阅端应用程序必须使用合适的逻辑来读取这些样本以保证请求的行为。</p>
<h2 id="17、DESTINATION-ORDER"><a href="#17、DESTINATION-ORDER" class="headerlink" title="17、DESTINATION_ORDER"></a>17、DESTINATION_ORDER</h2><p>DESTINATION_ORDER QoS策略控制数据实例的样本到达数据读者的顺序，如果HISTRORY策略的depth成员变量设为默认值1，实际将影响写者所写的所有最新数据样本，下面是DESTINATION_ORDER Qos的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum DestinationOrderQosPolicyKind &#123;</span><br><span class="line">  BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS,</span><br><span class="line">  BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct DestinationOrderQosPolicy &#123;</span><br><span class="line">  DestinationOrderQosPolicyKind kind;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>值BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS（默认）表示读者接收到的实例的样本按接收端的时间排序。值得注意的是，对于同一个写者发出的数据样本，接收方未必按顺序接收。如果需要强制按顺序接收，另一种方式BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS值将会用到。</li>
<li>值BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS表示数据实例的样本按发出的写者端的时间排序。需要注意的是，如果多个数据写者写相同的实例，必须保证多个写者所在的主机时钟同步。</li>
</ul>
<h2 id="18、WRITER-DATA-LIFECYCLE"><a href="#18、WRITER-DATA-LIFECYCLE" class="headerlink" title="18、WRITER_DATA_LIFECYCLE"></a>18、WRITER_DATA_LIFECYCLE</h2><p>WRITER_DATA_LIFECYCLE QoS策略控制数据写者管理的数据实例集合，下面是WRITER_DATA_LIFECYCLE QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct WriterDataLifecycleQosPolicy &#123;</span><br><span class="line">  boolean autodispose_unregistered_instances;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当成员autodispose_unregistered_instances设为true时（默认），数据写者在实例注销时自动清除。在有的情况下，当实例注销时，这是一个不错的实例保护方式。比如，该策略允许EXCLUSIVE（独占）式的数据写者优雅地遵从后续的读者而不影响实例的状态，删除一个数据写者会隐含的注销读者保存的先前的所有样本。</p>
<h2 id="19、READER-DATA-LIFECYCLE"><a href="#19、READER-DATA-LIFECYCLE" class="headerlink" title="19、READER_DATA_LIFECYCLE"></a>19、READER_DATA_LIFECYCLE</h2><p>READER_DATA_LIFECYCLE QoS策略控制数据读者管理的数据实例集合，下面是READER_DATA_LIFECYCLE QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct ReaderDataLifecycleQosPolicy &#123;</span><br><span class="line">  Duration_t autopurge_nowriter_samples_delay;</span><br><span class="line">  Duration_t autopurge_disposed_samples_delay;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通常，数据读者保存实例的样本直到与该样本没有任何关联的写者为止，实例已经被处理，实例要么被清除，要么被应用程序读取。</p>
<p>在有些情况下，由于资源的使用问题，需要有合理的约束方式。例如，在故障切换的环境中，该策略允许晚加入的数据写者延长实例的生命周期。</p>
<p>成员autopurge_nowriter_samples_delay可控制读者在资源回收之前所要等待的时间，实例的状态转移为NOT_ALIVE_NO_WRITERS，该成员的默认值为无穷大。</p>
<p>成员autopurge_disposed_samples_delay可控制读者在资源回收之前所要等待的时间，实例的状态转移为NO_ALIVE_DISPOSED，该成员的默认值为无穷大。</p>
<h2 id="20、TIME-BASED-FILTER"><a href="#20、TIME-BASED-FILTER" class="headerlink" title="20、TIME_BASED_FILTER"></a>20、TIME_BASED_FILTER</h2><p>TIME_BASED_FILTER QoS策略可以用于指定接收者多长时间接收数据。对于不同的数据样本，不管发布者以多快的速度发布数据，在订阅端，都可以指定数据实例接收更新样本的最小间隔时间，下面是TIME_BASED_FILTER QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct TimeBasedFilterQosPolicy&#123;</span><br><span class="line">  Duration_t minimum_separation;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>数据读者可以指定一个时间间隔（minimum_separation），该间隔指定了实例更新的的最小时间间隔；它允许数据读者在不影响关联的数据写者状态的前提下，可以修改。默认的minimum_separation是0，表示没有间隔。该QoS策略不会节省带宽，实例值的更新仍然会发送给订阅者进程，它只会影响那些数据读者获取的样本。</p>
<h2 id="21、OWNERSHIP"><a href="#21、OWNERSHIP" class="headerlink" title="21、OWNERSHIP"></a>21、OWNERSHIP</h2><p>OWNERSHIP策略控制是否允许多个数据写者为同一个实例发布样本。所有权可以为EXCLUSIVE和SHARED方式，下面是OWNERSHIP QoS策略IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enum OwnershipQosPolicyKind &#123;</span><br><span class="line">  SHARED_OWNERSHIP_QOS,</span><br><span class="line">  EXCLUSIVE_OWNERSHIP_QOS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct OwnershipQosPolicy &#123;</span><br><span class="line">  OwnershipQosPolicyKind kind;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>kind成员设为共享方式SHARED_OWNERSHIP_QOS，表示允许多个数据写者更新同一个数据实例。如果kind成员设置为独占式EXCLUSIVE_OWNERSHIP_QOS，表示只允许具有实例所有权的数据写者更新实例。实例的所有者是由OWNERSHIP_STRENGTH策略决定的；OWNERSHIP_STRENGTH策略中成员变量value取值最大的数据写者为实例的所有者。影响所有权还有一个可能的因素，具有最高值的写者是否还存活着，这个由LIVELINESS策略决定。</p>
<h2 id="22、OWNERSHIP-STRENGTH"><a href="#22、OWNERSHIP-STRENGTH" class="headerlink" title="22、OWNERSHIP_STRENGTH"></a>22、OWNERSHIP_STRENGTH</h2><p>OWNERSHIP_STRENGTH策略与OWNERSHI策略配合使用，当OWNERSHI的kind设为独占式EXCLUSIVE时有效，下面是OWNERSHIP_STRENGTH QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct OwnershipStrengthQosPolicy &#123;</span><br><span class="line">  long value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>value成员变量用来确定数据写者是否是数据实例的所有权者，它的默认值为0。</p>
<h2 id="策略使用示例"><a href="#策略使用示例" class="headerlink" title="策略使用示例"></a>策略使用示例</h2><p>下面的示例代码演示了Qos策略在发布端的应用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DDS::DataWriterQos dw_qos;</span><br><span class="line">pub-&gt;get_default_datawriter_qos(dw_qos);</span><br><span class="line"></span><br><span class="line">dw_qos.history.kind = DDS::KEEP_ALL_HISTORY_QOS;</span><br><span class="line">dw_qos.reliability.kind = DDS::RELIABLE_RELIABILITY_QOS;</span><br><span class="line">dw_qos.reliability.max_blocking_time.sec = 10;</span><br><span class="line">dw_qos.reliability.max_blocking_time.nanosec = 0;</span><br><span class="line">dw_qos.resource_limits.max_samples_per_instance = 100;</span><br><span class="line"></span><br><span class="line">DDS::DataWriter_var dw =</span><br><span class="line">  pub-&gt;create_datawriter(topic, dw_qos, 0, // No listener</span><br><span class="line">                     OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br></pre></td></tr></table></figure>

<p>上述代码创建了发布端的数据写者，试用了以下几种Qos策略：</p>
<ul>
<li>HISTORY 策略，取值为保持所有；</li>
<li>REALIBAILITY 策略，设置可靠类型的最大阻塞时间为10秒；</li>
<li>RESOURCE_LIMIT策略，设置每个实例的的最大样本数为100。</li>
</ul>
<p>以上策略的组合意味着：当100个样本等待传送时，写者在返回错误码前可以阻塞多达10秒。如果相同的策略应用在数据读者上，置意味着：直至有100个未读的样本排队之后，允许有样本被拒收。被拒绝的样本会被丢弃掉，并更新SampleRejectStatus(样本拒收状态)。</p>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2016/03/20/OpenDDS之Qos策略(3)/" data-id="ck0rt0auo00281ndxthsdri00" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Qos/">Qos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/策略使用/">策略使用</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/策略说明/">策略说明</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OpenDDS之Qos策略(2)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/23/OpenDDS之Qos策略(2)/" class="article-date">
  <time datetime="2015-11-22T16:00:00.000Z" itemprop="datePublished">2015-11-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/23/OpenDDS之Qos策略(2)/">OpenDDS之Qos策略(2)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>OpenDDS主要支持22种Qos，前一篇<a href="https://lyingbo.github.io/2014/09/16/OpenDDS%E4%B9%8BQos%E7%AD%96%E7%95%A5(1)" target="_blank" rel="noopener">OpenDDS之Qos策略(1)</a>已对Qos整体、以及默认值做了介绍，接下来介绍这22种Qos的具体内容和用法，由于内容较多，分两篇来完成。</p>
<h2 id="1、LIVELINESS"><a href="#1、LIVELINESS" class="headerlink" title="1、LIVELINESS"></a>1、LIVELINESS</h2><p>LIVELINESS策略主要应用于主题，数据写者，数据读者实体中。在主题中设置该策略，意味着对于所有发布订阅该主题的数据写者、数据读者都是有效的，下面是LIVELINESS QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum LivelinessQosPolicyKind &#123;</span><br><span class="line">  AUTOMATIC_LIVELINESS_QOS,</span><br><span class="line">  MANUAL_BY_PARTICIPANT_LIVELINESS_QOS,</span><br><span class="line">  MANUAL_BY_TOPIC_LIVELINESS_QOS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct LivelinessQosPolicy &#123;</span><br><span class="line">  LivelinessQosPolicyKind kind;</span><br><span class="line">  Duration_t lease_duration;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>LIVELINESS策略控制服务何时以及如何检测参与者是否还存活，存活表示参与者仍然处于可访问和激活状态。kind成员设置检测方式为自动或是实体手动检测，把kind设为AUTOMATIC_LIVELINESS_QOS，表示服务如果在lease_duration时间周期内没有任何网络流量，则自动的发出表示参与者存活的信息。把kind设为MANUAL_BY_PARTICIPANT_LIVELINESS_QOS或者是MANUAL_BY_TOPIC_LIVELINESS_QOS表示实体要在指定的心跳间隔内写入数据样本或者发送确认在线的消息，心跳间隔时间由lease_duration字段指定。lease_duration的默认值为无穷大，表示禁用存活检测。</p>
<p>手动发布存活消息而不发布数据样本，可以在指定的心跳间隔时间内通过调用数据写者或者域参与者的assert_liveliness()操作来实现。</p>
<p>数据写者指定（提供）自己的心跳数据准则，数据读者指定期望的写者的心跳数据。如果没有在心跳间隔期间内收到写者的数据(既没有样本数据，也没有确认存活的消息)，将会触发LIVELINESS_CHANGED_STATUS通信状态改变，并通知应用程序（通过调用数据写者监听者的on_liveliness_changed()回调函数）。</p>
<p>该策略的兼容性是在数据读者和数据写者之间关联关系建立的时候检测的，要建立关联关系，必须保证两端的策略值的兼容性。数据读者需要的策略和数据写者提供的策略的比较值决定了相容性。在决定相容性的时候，两种策略（AUTO、MANUAL）都需要和lease_duration的值相比较。写者提供的策略值必须大于或等于读者需要的策略值。该策略值的排序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MANUAL_BY_TOPIC_LIVELINESS_QOS &gt; MANUAL_BY_PARTICIPANT_LIVELINESS_QOS &gt; AUTOMATIC_LIVELINESS_QOS</span><br></pre></td></tr></table></figure>

<p>此外，写者提供的lease_duration必须小于或者等于读者的lease_duration。这些情况都必须符合提供、请求策略的兼容性要求，考虑兼容性和关联关系的建立。</p>
<h2 id="2、RELIABILITY"><a href="#2、RELIABILITY" class="headerlink" title="2、RELIABILITY"></a>2、RELIABILITY</h2><p>RELIABILITY策略主要应用于主题，数据读者，数据写者实体中，下面是RELIABILITY QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum ReliabilityQosPolicyKind &#123;</span><br><span class="line">  BEST_EFFORT_RELIABILITY_QOS,</span><br><span class="line">  RELIABLE_RELIABILITY_QOS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct ReliabilityQosPolicy &#123;</span><br><span class="line">  ReliabilityQosPolicyKind kind;</span><br><span class="line">  Duration_t max_blocking_time;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该策略控制数据读者处理样本数据的方式。把kind设置为BEST_EFFORT_RELIABILITY_QOS表示数据读写者尽力交付，不保证样本数据的可靠性传输，在某些情况下，允许样本丢弃。把kind设置为RELIABLE_RELIABILITY_QOS表示服务最终把样本传送给合适的数据读者。</p>
<p>当HISTORY QoS策略设置为KEEP_ALL_HISTORY_QOS，并且数据写者在写数据遇到资源限制（因为传输反压，详见6）时，会用到该策略的max_blocking_time字段。当这种情况发生时，数据写者会阻塞，如果阻塞时间超过了max_blocking_time指定的值，再调用写操作就会返回一个写超时的错误码。对于数据读者和主题，该策略的默认值是“BEST_EFFORT，对于数据写者，默认值是RELIABLE。</p>
<p>该策略的兼容性在数据写者和数据读者建立关联关系的时候，就需要考虑。要成功建立关联关系，两边的取值一定要相互兼容。该策略的兼容性要求数据写者的策略值一定要大于或等于数据读者的策略值。</p>
<h2 id="3、HISTORY"><a href="#3、HISTORY" class="headerlink" title="3、HISTORY"></a>3、HISTORY</h2><p>HISTORY策略指定数据读者和数据写者保留特定实例样本的数量。对于数据写者，这些样本被保存直到发布者取出它们并成功的发送给所有关联的订阅者；对于数据读者，这些样本被保存直到应用程序取出它们。该策略主要应用于主题、数据写者、数据读者实体，下面是HISTORY QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum HistoryQosPolicyKind &#123;</span><br><span class="line">  KEEP_LAST_HISTORY_QOS,</span><br><span class="line">  KEEP_ALL_HISTORY_QOS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct HistoryQosPolicy &#123;</span><br><span class="line">  HistoryQosPolicyKind kind;</span><br><span class="line">  long depth;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>取值KEEP_ALL_HISTORY_QOS表示所有的样本都将保存。当指定KEEP_ALL_HISTORY_QOS并且未读取的样本数量等于资源限制策略所设置的max_samples_per_instance时，之后新到来的样本都将被拒收。取值KEEP_LAST_HISTORY_QOS表示只保存depth条最新样本。当数据写者保存的样本条数已经达到depth时，新写入的样本会被排入待发送队列中，而最早写入的样本将会被丢弃。</p>
<p>该策略的默认值是“KEEP_LAST_HISTORY_QOS”，并且depth为1。</p>
<h2 id="4、DURABILITY"><a href="#4、DURABILITY" class="headerlink" title="4、DURABILITY"></a>4、DURABILITY</h2><p>DURABILITY策略控制数据写者是否管理已发出的样本。该策略主要应用于主题，数据写者，数据读者实体，下面是DURABILITY QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum DurabilityQosPolicyKind &#123;</span><br><span class="line">  VOLATILE_DURABILITY_QOS,  // Least Durability</span><br><span class="line">  TRANSIENT_LOCAL_DURABILITY_QOS,</span><br><span class="line">  TRANSIENT_DURABILITY_QOS,</span><br><span class="line">  PERSISTENT_DURABILITY_QOS  // Greatest Durability</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct DurabilityQosPolicy &#123;</span><br><span class="line">  DurabilityQosPolicyKind kind;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>kind的默认值是VOLATILE_DURABILITY_QOS:</p>
<ul>
<li>为VOLATILE_DURABILITY_QOS表示样本在发送给已知的订阅者之后即丢弃。因此，订阅者不能找回在它与发布者建立连接之前的任何样本。</li>
<li>为TRANSIENT_LOCAL_DURABILITY_QOS表示数据读者一旦和数据写者建立连接，写者将发送历史中的所有样本。</li>
<li>为TRANSIENT_DURABILITY_QOS表示只要进程没有退出，数据写者的样本就会在内存保留，但不保存在外部存储器中。当同一个域中的数据读者订阅了相同的主题及分区时，写者把所有缓存的样本全部发送出去。</li>
<li>为PERSISTENT_DURABILITY_QOS表示除了提供与TRANSIENT_DURABILITY_QOS相同的功能外，还把样本保留在持久的外部存储器中，即便进程退出，样本仍然可以幸存。</li>
</ul>
<p>一旦该策略被指定为TRANSIENT或PERSISTENT时，需要设置DURABILITY_SERVICE QoS策略调节持久度缓存的参数。</p>
<p>该策略的兼容性需要在数据写者和数据读者之间建立关联关系的时候考虑。要成功建立关联关系，两边的值一定要兼容。要求数据写者的持久性值一定要大于或等于数据读者的值。持久性大小关系如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PERSISTENT_DURABILITY_QOS &gt; TRANSIENT_DURABILITY_QOS &gt; TRANSIENT_LOCAL_DURABILITY_QOS &gt; VOLATILE_DURABILITY_QOS</span><br></pre></td></tr></table></figure>

<h2 id="5、DURABILITY-SERVICE"><a href="#5、DURABILITY-SERVICE" class="headerlink" title="5、DURABILITY_SERVICE"></a>5、DURABILITY_SERVICE</h2><p>DURABILITY_SERVICE策略控制TRANSIENT 或 PERSISTENT的持久缓存中样本的删除。该策略主要应用于主题，数据写者实体。该策略还提供了一种用于设置HISTORY 和RESOURCE_LIMITS策略关于样本缓冲参数的方式，下面是DURABILITY_SERVICE QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct DurabilityServiceQosPolicy &#123;</span><br><span class="line">  Duration_t             service_cleanup_delay;</span><br><span class="line">  HistoryQosPolicyKind   history_kind;</span><br><span class="line">  long                   history_depth;</span><br><span class="line">  Long                   max_samples;</span><br><span class="line">  long                   max_instances;</span><br><span class="line">  long                   max_samples_per_instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该策略中的字段与HISTORY 和RESOURCE_LIMITS中的成员有些相似，但与它们无关。字段service_cleanup_delay可以按需要设定，默认值为0，表示不删除缓存中的样本。</p>
<h2 id="6、RESOURCE-LIMITS"><a href="#6、RESOURCE-LIMITS" class="headerlink" title="6、RESOURCE_LIMITS"></a>6、RESOURCE_LIMITS</h2><p>RESOURCE_LIMITS策略指定可以消耗的资源的数量。该策略主要应用于主题，数据写者，数据读者实体，下面是RESOURCE_LIMITS QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct ResourceLimitsQosPolicy &#123;</span><br><span class="line">  long max_samples;</span><br><span class="line">  long max_instances;</span><br><span class="line">  long max_samples_per_instance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员max_samples表示一个数据写者或数据读者可以管理的所有实例的样本总数。成员max_instances表示数据写者或数据读者可以管理的最大实例数。 成员max_samples_per_instance表示一个数据写者或数据读者可以管理的单个实例的最大样本数。以上成员的默认值都是DDS::LENGTH_UNLIMITED，表示无限制。</p>
<p>该策略应用于数据写者时，写者将把因为传输后压还没有发送给数据读者的样本排队发送；该策略应用于数据读者时，读者将把已接收但还未读取/使用的样本缓存在队列中。</p>
<h2 id="7、PARTITION"><a href="#7、PARTITION" class="headerlink" title="7、PARTITION"></a>7、PARTITION</h2><p>PARTITION QoS 策略允许在一个域中创建逻辑分区。仅当数据读者和数据写者的分区字符串匹配时，才允许在二者间建立关联关系。该策略主要应用于发布者和订阅者实体，下面是PARTITION QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct PartitionQosPolicy &#123;</span><br><span class="line">  StringSeq name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>name成员默认值为空，表示实体参与到默认的分区中。分区名可以包含通配符，通配符的规则与POSIX的fnmatch函数（POSIX 1003.2-1992 section B.6）一致。</p>
<p>数据读者和数据写者的关联关系的建立依赖于发布端和订阅端的分区字符串的匹配。如果分区匹配失败，不会触发任何回调或者设置状态值。</p>
<p>该策略的值可以在运行时修改，此修改会引起关联关系的移除或添加。</p>
<h2 id="8、DEADLINE"><a href="#8、DEADLINE" class="headerlink" title="8、DEADLINE"></a>8、DEADLINE</h2><p>DEADLINE QoS策略允许应用程序在指定的时间内检测数据是否被写入或者读取。该策略主要应用于主题、数据写者、数据读者实体，下面是DEADLINE QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct DeadlineQosPolicy &#123;</span><br><span class="line">  Duration_t period;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>period成员的默认值是无穷大，表示该策略不起作用。如果该策略的值设定为有限值时，数据写者将会监视应用程序的写入行为，当在设定的期限内没有数据写入时，DDS会设置相应的状态条件并触发on_offered_deadline_missed()回调。如果数据读者在设定的期限内没有收到数据时，DDS也会设置相应的状态条件并触发on_offered_deadline_missed()回调。</p>
<p>该策略的兼容性，在数据写者和数据读者建立关联关系的时候就需要考虑。要求：数据读者的period值一定不能小于数据写者的值。</p>
<p>当关联实体被启动之后，该策略的值也是可以修改的。在这种情况下，只有修改后的策略值与关联的实体的策略值一致，才能修改成功。如果该策略用于主题，那么该策略的修改仅仅会影响在改变之后创建的数据读者和数据写者，任何已经创建的读者或者写者，不会受到影响。</p>
<h2 id="9、LIFESPAN"><a href="#9、LIFESPAN" class="headerlink" title="9、LIFESPAN"></a>9、LIFESPAN</h2><p>LIFESPAN QoS策略允许应用程序指定一个样本什么时候失效。已经失效的样本不会传送给订阅者。该策略主要应用于主题，数据写者实体，下面是LIFESPAN的QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct LifespanQosPolicy &#123;</span><br><span class="line">  Duration_t duration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>duration成员的默认值是无穷大，表示样本永不失效。OpenDDS1.5支持的LIFESPAN检测是当发布者使用DURABILITY kind时有效。当前的OpenDDS实现并不移除那些已经放入数据读者和数据写者缓存之后失效的样本。</p>
<p>该策略的值可以在运行时修改，修改后的策略只影响之后发布的数据。</p>
<h2 id="10、USER-DATA"><a href="#10、USER-DATA" class="headerlink" title="10、USER_DATA"></a>10、USER_DATA</h2><p>USER_DATA策略为应用程序提供保存附加信息的方式，该策略主要应用于域参与者、数据读者、数据写者实体，下面是USER_DATA QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct UserDataQosPolicy &#123;</span><br><span class="line">  sequence value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Value的默认值为空，表示没有任何附加信息。该字段可以设为任意次序的8-bit，以把信息附加到已经创建的实体中。USER_DATA策略在各自的内建主题数据中都是可以获得的。远端的应用程序通过内建主题获得信息，并根据自己的目的来使用这些信息。例如，应用程序可以使用USER_DATA策略附加安全凭证来认证信息源。</p>
<h2 id="11、TOPIC-DATA"><a href="#11、TOPIC-DATA" class="headerlink" title="11、TOPIC_DATA"></a>11、TOPIC_DATA</h2><p>TOPIC_DATA策略主要应用于主题，下面是TOPIC_DATA QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct TopicDataQosPolicy &#123;</span><br><span class="line">  sequence value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Value的默认值为空，表示没有任何附加信息。该字段可以设为任意次序的8-bit额外信息到主题中。TOPIC_DATA策略对、数据读者，数据写者、主题和内建主题数据有效。远程的应用程序可以通过内建主题获取这些信息，并应用于应用程序自行定义。</p>
<h2 id="12、GROUP-DATA"><a href="#12、GROUP-DATA" class="headerlink" title="12、GROUP_DATA"></a>12、GROUP_DATA</h2><p>GROUP_DATA策略主要应用于发布者和订阅者实体，下面是GROUP_DATA QoS策略的IDL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct GroupDataQosPolicy &#123;</span><br><span class="line">  sequence value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Value的默认值为空，表示没有任何附加信息。该字段可以设为任意次序的8-bit。GROUP_DATA的值通过内建主题传播。发布端数据写者的内置主题包括GROUP_DATA的值，订阅端则是数据读者包括GROUP_DATA的值。GROUP_DATA策略可以用来实现和在7中描述的PARTITION策略相似的机制。</p>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2015/11/23/OpenDDS之Qos策略(2)/" data-id="ck0rt0aue00261ndxkn0wxvha" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Qos/">Qos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/策略使用/">策略使用</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/策略说明/">策略说明</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OpenDDS之Qos策略(1)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/09/16/OpenDDS之Qos策略(1)/" class="article-date">
  <time datetime="2014-09-15T16:00:00.000Z" itemprop="datePublished">2014-09-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/16/OpenDDS之Qos策略(1)/">OpenDDS之Qos策略(1)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>OpenDDS对DDS规范（<a href="http://www.omg.org/cgi-bin/doc?formal/07-01-01.pdf" target="_blank" rel="noopener">OMG Document formal/07-01-01</a>）定义的22种QoS策略全部支持。</p>
<p>应用程序通过参与者的QoS约束，来指定需要的行为，然后由DDS的服务决定如何实现这些行为，这些策略应用于所有DDS实体（主题、数据写者、数据读者、发布者、订阅者、域参与者），但不是所有的策略都适用于所有的实体类型。</p>
<p>发布者和订阅者通过RxO模式相匹配，订阅者请求一组策略，发布者提供一组QoS策略给潜在的订阅者，然后DDS试图将请求的策略和提供的策略相匹配，如果这些策略相匹配则将它们关联起来。</p>
<p>在前面的《<a href="https://lyingbo.github.io/categories/OpenDDS" target="_blank" rel="noopener">基于OpenDDS的应用程序开发</a>》博文中，我们采用了默认的QoS策略，接下来的几篇博文将详细介绍每个QoS策略的相关细节。</p>
<h2 id="Qos策略"><a href="#Qos策略" class="headerlink" title="Qos策略"></a>Qos策略</h2><p>每个策略都定义了自己的结构，每个实体都支持策略的一个子集，并且定义了一个由被支持的策略结构体所组成的QoS结构体，一个给定实体的可用策略集不会受到QoS结构体中包含的策略结构体的限制，例如，发布者的QoS结构体的IDL定义格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module DDS &#123;</span><br><span class="line"> struct PublisherQos &#123;</span><br><span class="line">   PresentationQosPolicy presentation;</span><br><span class="line">   PartitionQosPolicy partition;</span><br><span class="line">   GroupDataQosPolicy group_data;</span><br><span class="line">   EntityFactoryQosPolicy entity_factory;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>设置一个策略就像获得一个已经有默认值的结构体一样简单，并在必要的时候修改个别策略值，然后将QoS结构体应用到实体中（通常是在实体被建立的时候），后续的章节中将详细说明如何获取各个实体的缺省QoS值。</p>
<p>应用程序可以通过调用set_qos()操作来改变任意实体的QoS策略。如果该QoS策略变得不再兼容，则现有的连接将会移除，否则，如果该Qos策略变得兼容了，将会有新的连接添加。该改变将会通过相应的实体调用QoS更新操作通知DCPSInfoRepo，DCPSInfoRepo将会依据Qos策略规范来重新检测兼容性和关联性，如果兼容性检测失败，set_qos()调用将会返回错误，关联性检测将以移除现有的连接或增加新的连接为结果。</p>
<p>如果试图去改变一个不能改变的QoS策略，set_qos()操作将会返回DDS::RETCODE_IMMUTABLE_POLICY。可以改变的QoS策略有如下几个：USER_DATA,TOPIC_DATA,LIFESPAN,OWNERSHIP_STRENGTH,TIME_BASED_FILTER,ENTITY_FACTORY,WRITER_DATA_LIFECYCLE,READER_DATA_LIFECYCLE，它们不需要重新检测兼容性和关联性。QoS策略DEADLINE和LATENCY_BUDGET需要重新检测相容性，关联性不需要。QoS策略PARTITION恰好相反，只需重新检测关联性，对于兼容性则不需重新检测。</p>
<h2 id="默认Qos策略值"><a href="#默认Qos策略值" class="headerlink" title="默认Qos策略值"></a>默认Qos策略值</h2><p>应用程序获取实体的默认QoS策略，通过实例化该实体的一个对应的Qos结构体，然后调用实体工厂的get_default_entity_qos()操作将它获取回来（例如，对于发布者和订阅者，可以通过使用域参与者来获取默认QoS）。</p>
<p>下面的示例代码说明了对于发布者、订阅者、主题、域参与者、数据写者、数据读者如何获取默认QoS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// Get default Publisher QoS from a DomainParticipant:</span><br><span class="line">DDS::PublisherQos pub_qos;</span><br><span class="line">DDS::ReturnCode_t ret;</span><br><span class="line">ret = domain_participant-&gt;get_default_publisher_qos(pub_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default publisher QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get default Subscriber QoS from a DomainParticipant:</span><br><span class="line">DDS::SubscriberQos sub_qos;</span><br><span class="line">ret = domain_participant-&gt;get_default_subscriber_qos(sub_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default subscriber QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get default Topic QoS from a DomainParticipant:</span><br><span class="line">DDS::TopicQos topic_qos;</span><br><span class="line">ret = domain_participant-&gt;get_default_topic_qos(topic_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default topic QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get default DomainParticipant QoS from a DomainParticipantFactory:</span><br><span class="line">DDS::DomainParticipantQos dp_qos;</span><br><span class="line">ret = domain_participant_factory-&gt;get_default_participant_qos(dp_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default participant QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get default DataWriter QoS from a Publisher:</span><br><span class="line">DDS::DataWriterQos dw_qos;</span><br><span class="line">ret = pub-&gt;get_default_datawriter_qos(dw_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default data writer QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Get default DataReader QoS from a Subscriber:</span><br><span class="line">DDS::DataReaderQos dr_qos;</span><br><span class="line">ret = pub-&gt;get_default_datareader_qos(dr_qos);</span><br><span class="line">if (DDS::RETCODE_OK != ret) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Could not get default data reader QoS&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的表格总结了在OpenDDS中用到的每一种实体类型的默认QoS策略。</p>
<p>表1、默认域参与者QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>成员</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>USER_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>
<tr>
<td>ENTITY_FACTORY</td>
<td>autoenable_created_entities</td>
<td>true</td>
</tr>
</tbody></table>
<p>表2、默认主题QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>成员</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>TOPIC_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>
<tr>
<td>DURABILITY</td>
<td>kind</td>
<td>VOLATILE_DURABILITY_QOS</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td>service_cleanup_delay.sec</td>
<td>DURATION_ZERO_SEC</td>
</tr>
<tr>
<td></td>
<td>service_cleanup_delay.nanosec</td>
<td>DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td></td>
<td>history_kind</td>
<td>KEEP_LAST_HISTORY_QOS</td>
</tr>
<tr>
<td></td>
<td>history_depth</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>max_samples</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td></td>
<td>max_instances</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td></td>
<td>max_samples_per_instance</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>DEADLINE</td>
<td>period.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>period.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>LATENCY_BUDGET</td>
<td>duration.sec</td>
<td>DURATION_ZERO_SEC</td>
</tr>
<tr>
<td></td>
<td>duration.nanosec</td>
<td>DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td>kind</td>
<td>AUTOMATIC_LIVELINESS_QOS</td>
</tr>
<tr>
<td></td>
<td>lease_duration.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>lease_duration.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td>kind</td>
<td>BEST_EFFORT_RELIABILITY_QOS</td>
</tr>
<tr>
<td></td>
<td>max_blocking_time.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>max_blocking_time.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>DESTINATION_ORDER</td>
<td>kind</td>
<td>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</td>
</tr>
<tr>
<td>HISTORY</td>
<td>kind</td>
<td>KEEP_LAST_HISTORY_QOS</td>
</tr>
<tr>
<td></td>
<td>depth</td>
<td>1</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td>max_samples</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td></td>
<td>max_instances</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td></td>
<td>max_samples_per_instance</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>TRANSPORT_PRIORITY</td>
<td>value</td>
<td>0</td>
</tr>
<tr>
<td>LIFESPAN</td>
<td>duration.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>duration.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>OWNERSHIP</td>
<td>kind</td>
<td>SHARED_OWNERSHIP_QOS</td>
</tr>
</tbody></table>
<p>表3、默认发布者QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>成员</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>PRESENTATION</td>
<td>access_scope</td>
<td>INSTANCE_PRESENTATION_QOS</td>
</tr>
<tr>
<td></td>
<td>coherent_access</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>ordered_access</td>
<td>0</td>
</tr>
<tr>
<td>PARTITION</td>
<td>name</td>
<td>(empty sequence)</td>
</tr>
<tr>
<td>GROUP_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>
<tr>
<td>ENTITY_FACTORY</td>
<td>autoenable_created_entities</td>
<td>true</td>
</tr>
</tbody></table>
<p>表4、默认订阅者QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>成员</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>PRESENTATION</td>
<td>access_scope</td>
<td>INSTANCE_PRESENTATION_QOS</td>
</tr>
<tr>
<td></td>
<td>coherent_access</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>ordered_access</td>
<td>0</td>
</tr>
<tr>
<td>PARTITION</td>
<td>name</td>
<td>(empty sequence)</td>
</tr>
<tr>
<td>GROUP_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>
<tr>
<td>ENTITY_FACTORY</td>
<td>autoenable_created_entities</td>
<td>true</td>
</tr>
</tbody></table>
<p>表5、默认数据写者QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>成员</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>DESTINATION_ORDER</td>
<td>kind</td>
<td>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</td>
</tr>
<tr>
<td>HISTORY</td>
<td>kind</td>
<td>KEEP_LAST_HISTORY_QOS</td>
</tr>
<tr>
<td></td>
<td>depth</td>
<td>1</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td>max_samples</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td></td>
<td>max_instances</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td></td>
<td>max_samples_per_instance</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>TRANSPORT_PRIORITY</td>
<td>value</td>
<td>0</td>
</tr>
<tr>
<td>LIFESPAN</td>
<td>duration.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>duration.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>USER_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>
<tr>
<td>OWNERSHIP</td>
<td>kind</td>
<td>SHARED_OWNERSHIP_QOS</td>
</tr>
<tr>
<td>OWNERSHIP_STRENGTH</td>
<td>value</td>
<td>0</td>
</tr>
<tr>
<td>WRITER_DATA_LIFECYCLE</td>
<td>autodispose_unregistered_instances</td>
<td>1</td>
</tr>
<tr>
<td>DURABILITY</td>
<td>kind</td>
<td>VOLATILE_DURABILITY_QOS</td>
</tr>
<tr>
<td>DURABILITY_SERVICE</td>
<td>service_cleanup_delay.sec</td>
<td>DURATION_ZERO_SEC</td>
</tr>
<tr>
<td></td>
<td>service_cleanup_delay.nanosec</td>
<td>DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td></td>
<td>history_kind</td>
<td>KEEP_LAST_HISTORY_QOS</td>
</tr>
<tr>
<td></td>
<td>history_depth</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>max_samples</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td></td>
<td>max_instances</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td></td>
<td>max_samples_per_instance</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>DEADLINE</td>
<td>period.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>period.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>LATENCY_BUDGET</td>
<td>duration.sec</td>
<td>DURATION_ZERO_SEC</td>
</tr>
<tr>
<td></td>
<td>duration.nanosec</td>
<td>DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td>kind</td>
<td>AUTOMATIC_LIVELINESS_QOS</td>
</tr>
<tr>
<td></td>
<td>lease_duration.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>lease_duration.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td>kind</td>
<td>RELIABLE_RELIABILITY_QOS</td>
</tr>
<tr>
<td></td>
<td>max_blocking_time.sec</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>max_blocking_time.nanosec</td>
<td>100000000 (100 ms)</td>
</tr>
</tbody></table>
<p>表6、默认数据读者QoS策略</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>成员</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>DURABILITY</td>
<td>kind</td>
<td>VOLATILE_DURABILITY_QOS</td>
</tr>
<tr>
<td>DEADLINE</td>
<td>period.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>period.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>LATENCY_BUDGET</td>
<td>duration.sec</td>
<td>DURATION_ZERO_SEC</td>
</tr>
<tr>
<td></td>
<td>duration.nanosec</td>
<td>DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td>LIVELINESS</td>
<td>kind</td>
<td>AUTOMATIC_LIVELINESS_QOS</td>
</tr>
<tr>
<td></td>
<td>lease_duration.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>lease_duration.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>RELIABILITY</td>
<td>kind</td>
<td>BEST_EFFORT_RELIABILITY_QOS</td>
</tr>
<tr>
<td></td>
<td>max_blocking_time.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>max_blocking_time.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td>DESTINATION_ORDER</td>
<td>kind</td>
<td>BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS</td>
</tr>
<tr>
<td>HISTORY</td>
<td>kind</td>
<td>KEEP_LAST_HISTORY_QOS</td>
</tr>
<tr>
<td></td>
<td>depth</td>
<td>1</td>
</tr>
<tr>
<td>RESOURCE_LIMITS</td>
<td>max_samples</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td></td>
<td>max_instances</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td></td>
<td>max_samples_per_instance</td>
<td>LENGTH_UNLIMITED</td>
</tr>
<tr>
<td>USER_DATA</td>
<td>value</td>
<td>(not set)</td>
</tr>
<tr>
<td>OWNERSHIP</td>
<td>kind</td>
<td>SHARED_OWNERSHIP_QOS</td>
</tr>
<tr>
<td>TIME_BASED_FILTER</td>
<td>minimum_separation.sec</td>
<td>DURATION_ZERO_SEC</td>
</tr>
<tr>
<td></td>
<td>minimum_separation.nanosec</td>
<td>DURATION_ZERO_NSEC</td>
</tr>
<tr>
<td>READER_DATA_LIFECYCLE</td>
<td>autopurge_nowriter_samples_delay.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>autopurge_nowriter_samples_delay.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
<tr>
<td></td>
<td>autopurge_disposed_samples_delay.sec</td>
<td>DURATION_INFINITY_SEC</td>
</tr>
<tr>
<td></td>
<td>autopurge_disposed_samples_delay.nanosec</td>
<td>DURATION_INFINITY_NSEC</td>
</tr>
</tbody></table>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2014/09/16/OpenDDS之Qos策略(1)/" data-id="ck0rt0aud00251ndxvdsuxnwt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Qos/">Qos</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/策略使用/">策略使用</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/策略说明/">策略说明</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基于OpenDDS应用程序开发(3)订阅端实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/29/基于OpenDDS应用程序开发(3)订阅端实现/" class="article-date">
  <time datetime="2014-07-28T16:00:00.000Z" itemprop="datePublished">2014-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/29/基于OpenDDS应用程序开发(3)订阅端实现/">基于OpenDDS应用程序开发(3)订阅端实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>连续的三篇博文演示如何基于OpenDDS开发应用程序，将数据从发布端节点发送到订阅端节点，该示例程序由一个发布者发布数据，一个订阅者订阅数据，使用默认的QoS策略和TCP/IP传输方式。</p>
<p>本文是第三篇，主要介绍开发一个简单的OpenDDS订阅端应用程序所涉及的步骤。省略一些不重要部分(如:#include部分和异常处理等)代码，只写出关键代码。</p>
<h2 id="1、新建订阅端工程："><a href="#1、新建订阅端工程：" class="headerlink" title="1、新建订阅端工程："></a>1、新建订阅端工程：</h2><p>参考前一博文中MPC的用法，在Demo.mpc文件中增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> project(*Subscriber) : dcpsexe_with_tcp &#123;</span><br><span class="line"></span><br><span class="line"> exename = subscriber</span><br><span class="line"> after += *idl</span><br><span class="line"></span><br><span class="line"> TypeSupport_Files &#123;</span><br><span class="line">   Demo.idl</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Source_Files &#123;</span><br><span class="line">   Subscriber.cpp</span><br><span class="line">   DataReaderListenerImpl.cpp</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Subscriber工程从父工程dcpsexe_with_tcp继承，这里直接使用idl工程中定义好的Demo.idl文件。</p>
<p>之后在Demo目录下新建三个文件：Subscriber.cpp、DataReaderListenerImpl.h、DataReaderListenerImpl.cpp，分别用来编写订阅端逻辑部分代码，并再次使用如下命令来生成Vs2008工程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mwc.pl -type vc9</span><br></pre></td></tr></table></figure>

<p>生成完成之后，使用Vs2008打开Demo.sln，就可以修改订阅端代码了：</p>
<h2 id="2、初始化参与者："><a href="#2、初始化参与者：" class="headerlink" title="2、初始化参与者："></a>2、初始化参与者：</h2><p>初始化订阅端参与者代码同发布端是完全一样的，在Subscriber.cpp文件中增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  try &#123;</span><br><span class="line">  </span><br><span class="line">   DDS::DomainParticipantFactory_var dpf =</span><br><span class="line">     TheParticipantFactoryWithArgs(argc, argv);</span><br><span class="line"></span><br><span class="line">   DDS::DomainParticipant_var participant =</span><br><span class="line">     dpf-&gt;create_participant(42, // Domain ID</span><br><span class="line">                         PARTICIPANT_QOS_DEFAULT,</span><br><span class="line">                         0,  // No listener required</span><br><span class="line">                         OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">   if (!participant) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;create_participant failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return 1 ;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="3、注册数据类型并创建主题："><a href="#3、注册数据类型并创建主题：" class="headerlink" title="3、注册数据类型并创建主题："></a>3、注册数据类型并创建主题：</h2><p>接下来，初始化数据类型和主题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Demo::PosTypeSupport_var mts = new Demo::PosTypeSupportImpl();</span><br><span class="line">if (DDS::RETCODE_OK != mts-&gt;register_type(participant, &quot;&quot;)) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed to register the PosTypeSupport.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CORBA::String_var type_name = mts-&gt;get_type_name();</span><br><span class="line">DDS::Topic_var topic =</span><br><span class="line">  participant-&gt;create_topic(&quot;Pos Demo&quot;,</span><br><span class="line">                        type_name,</span><br><span class="line">                        TOPIC_QOS_DEFAULT,</span><br><span class="line">                        0,   // No listener required</span><br><span class="line">                        OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!topic) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed to create_topic.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、创建订阅者："><a href="#4、创建订阅者：" class="headerlink" title="4、创建订阅者："></a>4、创建订阅者：</h2><p>调用create_subscriber()操作创建一个带有默认QoS策略的订阅者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DDS::Subscriber_var sub =</span><br><span class="line">  participant-&gt;create_subscriber(SUBSCRIBER_QOS_DEFAULT,</span><br><span class="line">                            0,  // No listener required</span><br><span class="line">                            OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!sub) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed to create_subscriber.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、创建数据读者及监听者："><a href="#5、创建数据读者及监听者：" class="headerlink" title="5、创建数据读者及监听者："></a>5、创建数据读者及监听者：</h2><p>订阅端需要给数据读者关联一个监听者，用来接收数据的到达，下面的代码定义了一个监听者对象，类DataReaderListenerImpl的实现将在下一部分介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DDS::DataReaderListener_var listener(new DataReaderListenerImpl);</span><br></pre></td></tr></table></figure>

<p>现在采用默认的QoS策略创建数据读者，并将它与主题、刚刚创建的监听者对象相关联起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DDS::DataReader_var dr =</span><br><span class="line">  sub-&gt;create_datareader(topic,</span><br><span class="line">                     DATAREADER_QOS_DEFAULT,</span><br><span class="line">                     listener,</span><br><span class="line">                     OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!dr) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;create_datareader failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后，主线程就可以自由的去处理其它工作了，当有数据到达时，OpenDDS会调用监听者对象的回调接口通知，只需要在DataReaderListenerImpl类的回调函数中接收需要的数据就可以了。</p>
<h2 id="6、数据读者监听者实现："><a href="#6、数据读者监听者实现：" class="headerlink" title="6、数据读者监听者实现："></a>6、数据读者监听者实现：</h2><p>监听者类继承自DDS规范的DDS::DataReaderListener接口，该接口定义了一些回调函数，每个回调函数被调用时，就是一个事件的通知，如：断开、重连等，以下是DataReaderListener接口的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">module DDS &#123;</span><br><span class="line"></span><br><span class="line"> local interface DataReaderListener : Listener &#123;</span><br><span class="line"></span><br><span class="line">   void on_requested_deadline_missed(in DataReader reader,</span><br><span class="line">                                 in RequestedDeadlineMissedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_requested_incompatible_qos(in DataReader reader,</span><br><span class="line">                                 in RequestedIncompatibleQosStatus status);</span><br><span class="line"></span><br><span class="line">   void on_sample_rejected(in DataReader reader,</span><br><span class="line">                        in SampleRejectedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_liveliness_changed(in DataReader reader,</span><br><span class="line">                          in LivelinessChangedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_data_available(in DataReader reader);</span><br><span class="line"></span><br><span class="line">   void on_subscription_matched(in DataReader reader,</span><br><span class="line">                            in SubscriptionMatchedStatus status);</span><br><span class="line"></span><br><span class="line">   void on_sample_lost(in DataReader reader, in SampleLostStatus status);</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在本例的DataReaderListenerImpl类中真正需要的实现的回调接口是on_data_available()，它也是我们需要重新派生该类的唯一成员函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">void DataReaderListenerImpl::on_data_available(DDS::DataReader_ptr reader) &#123;</span><br><span class="line"></span><br><span class="line"> num_reads_ ++;</span><br><span class="line"></span><br><span class="line"> try&#123;</span><br><span class="line"></span><br><span class="line">   Demo::PosDataReader_var reader_i = Demo::PosDataReader::_narrow(reader);</span><br><span class="line">   if (!reader_i) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;read: _narrow failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Demo::Pos pos;</span><br><span class="line">   DDS::SampleInfo si ;</span><br><span class="line">   DDS::ReturnCode_t status = reader_i-&gt;take_next_sample(pos, si) ;</span><br><span class="line">   if (status == DDS::RETCODE_OK) &#123;</span><br><span class="line">   </span><br><span class="line">     if (si.valid_data == 1) &#123;</span><br><span class="line">       std::cout &lt;&lt; &quot; Pos:pos_id = &quot; &lt;&lt; pos. pos_id &lt;&lt; std::endl</span><br><span class="line">                 &lt;&lt; &quot;  pos_x = &quot; &lt;&lt; pos. pos_x &lt;&lt; std::endl</span><br><span class="line">                 &lt;&lt; &quot;  pos_y = &quot; &lt;&lt; pos. pos_y &lt;&lt; std::endl;</span><br><span class="line">     &#125; else if (si.instance_state == DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE) &#123;</span><br><span class="line">       std::cout &lt;&lt; &quot;instance is disposed&quot; &lt;&lt; std::endl;</span><br><span class="line">     &#125; else if (si.instance_state == DDS::NOT_ALIVE_NO_WRITERS_INSTANCE_STATE) &#123;</span><br><span class="line">       std::cout &lt;&lt; &quot;instance is unregistered&quot; &lt;&lt; std::endl;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       std::cerr &lt;&lt; &quot;ERROR: received unknown instance state &quot;</span><br><span class="line">               &lt;&lt; si.instance_state &lt;&lt; std::endl;</span><br><span class="line">     &#125;</span><br><span class="line">	 </span><br><span class="line">   &#125; else if (status == DDS::RETCODE_NO_DATA) &#123;</span><br><span class="line">       cerr &lt;&lt; &quot;ERROR: reader received DDS::RETCODE_NO_DATA!&quot; &lt;&lt; std::endl;</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">       cerr &lt;&lt; &quot;ERROR: read Pos: &quot; &lt;&lt; status &lt;&lt; std::endl;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码将样本从数据读者中取出，如果成功并能返回有效数据，就打印出接收到数据的每一个字段。</p>
<p>每当有样本数据到达时，该函数就会被调用。</p>
<h2 id="7、实体清理："><a href="#7、实体清理：" class="headerlink" title="7、实体清理："></a>7、实体清理：</h2><p>在订阅完数据以后，需要清理与OpenDDS相关联的资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">participant-&gt;delete_contained_entities();</span><br><span class="line">dpf-&gt;delete_participant(participant);</span><br><span class="line">TheServiceParticipant-&gt;shutdown();</span><br></pre></td></tr></table></figure>

<p>调用域参与者的delete_contained_entities()操作删除所有该参与者创建的主题、订阅者。一旦执行完该操作，就可以使用域参与者工厂删除域参与者了。</p>
<h2 id="8、示例程序运行："><a href="#8、示例程序运行：" class="headerlink" title="8、示例程序运行："></a>8、示例程序运行：</h2><p>修改完以上代码并编译完成，就可以运行订阅端应用程序了，需要先运行DDS的信息仓库，开始中打开一个CMD窗口，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%DDS_ROOT%/bin/DCPSInfoRepo -ORBEndpoint iiop://localhost:12345</span><br></pre></td></tr></table></figure>

<p>再次打开一个CMD窗口，cd到Demo目录下，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscriber -DCPSInfoRepo corbaloc::localhost:12345/DCPSInfoRepo</span><br></pre></td></tr></table></figure>

<p>至此，订阅端应用程序就开发完成并运行起来了。</p>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2014/07/29/基于OpenDDS应用程序开发(3)订阅端实现/" data-id="ck0rt0asz000a1ndxstcbjvb0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MPC/">MPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/示例开发/">示例开发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/订阅数据/">订阅数据</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基于OpenDDS应用程序开发(2)公布端实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/10/基于OpenDDS应用程序开发(2)公布端实现/" class="article-date">
  <time datetime="2014-07-09T16:00:00.000Z" itemprop="datePublished">2014-07-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/10/基于OpenDDS应用程序开发(2)公布端实现/">基于OpenDDS应用程序开发(2)公布端实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>连续的三篇博文演示如何基于OpenDDS开发应用程序，将数据从发布端节点发送到订阅端节点，该示例程序由一个发布者发布数据，一个订阅者订阅数据，使用默认的QoS策略和TCP/IP传输方式。</p>
<p>本文是第二篇，主要介绍开发一个简单的OpenDDS公布端应用程序所涉及的步骤，省略一些不重要部分(如:#include部分和异常处理等)代码，只写出关键代码。</p>
<h2 id="1、新建公布端工程："><a href="#1、新建公布端工程：" class="headerlink" title="1、新建公布端工程："></a>1、新建公布端工程：</h2><p>参考前一博文中MPC的用法，在Demo.mpc文件中增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">project(*Publisher) : dcpsexe_with_tcp &#123;</span><br><span class="line"></span><br><span class="line"> exename = publisher</span><br><span class="line"> after += *idl</span><br><span class="line"></span><br><span class="line"> TypeSupport_Files &#123;</span><br><span class="line">   Demo.idl</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Source_Files &#123;</span><br><span class="line">   Publisher.cpp</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Publisher工程从父工程dcpsexe_with_tcp继承，这里直接使用idl工程中定义好的Demo.idl文件，之后在Demo目录下新建一个Publisher.cpp文件，用来编写公布端逻辑部分代码，并再次使用如下命令来生成Vs2008工程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mwc.pl -type vc9</span><br></pre></td></tr></table></figure>

<p>生成完成之后，使用Vs2008打开Demo.sln就可以修改Publisher.cpp中的代码了：</p>
<h2 id="2、初始化参与者："><a href="#2、初始化参与者：" class="headerlink" title="2、初始化参与者："></a>2、初始化参与者：</h2><p>main()函数的第一部分是为当前进程初始化一个OpenDDS参与者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line"></span><br><span class="line">   DDS::DomainParticipantFactory_var dpf =</span><br><span class="line">     TheParticipantFactoryWithArgs(argc, argv);</span><br><span class="line"></span><br><span class="line">   DDS::DomainParticipant_var participant =</span><br><span class="line">     dpf-&gt;create_participant(42, // domain ID</span><br><span class="line">                         PARTICIPANT_QOS_DEFAULT,</span><br><span class="line">                         0,  // No listener required</span><br><span class="line">                         OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">   if (!participant) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;create_participant failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>调用宏TheParticipantFactoryWithArgs，使用命令行参数初始化参与者工厂，这些命令行参数用来初始化ORB服务。</p>
<p>调用create_participant()操作，使用默认的QoS策略，在域参与者工厂中注册一个域参与者，并指定域ID为42，使用DDS默认的状态掩码，确保所有在中间件中的相关通信状态改变都能传递到应用程序中，域ID可以是在0x0~0x7FFFFFFF范围内的任意值，返回域参与者对象的引用，用来注册待公布的数据类型。</p>
<h2 id="3、注册数据类型并创建主题："><a href="#3、注册数据类型并创建主题：" class="headerlink" title="3、注册数据类型并创建主题："></a>3、注册数据类型并创建主题：</h2><p>首先，new一个PosTypeSupportImpl对象，然后调用register_type()操作注册一个带有类型名称的类型，示例中，使用空的类型名称，DDS缺省会把PosTypeSupport接口标识符作为该类型的名称，当然，也可以使用像“Pos”这样的特定类型名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Demo::PosTypeSupport_var mts = new Demo::PosTypeSupportImpl();</span><br><span class="line"> if (DDS::RETCODE_OK != mts-&gt;register_type(participant, &quot;&quot;)) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;register_type failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，从类型支持对象中获得注册的类型名称，调用create_topic()操作来创建主题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CORBA::String_var type_name = mts-&gt;get_type_name();</span><br><span class="line"></span><br><span class="line">DDS::Topic_var topic =</span><br><span class="line">participant-&gt;create_topic(&quot;Pos Demo&quot;,</span><br><span class="line">                        type_name,</span><br><span class="line">                        TOPIC_QOS_DEFAULT,</span><br><span class="line">                        0,   // No listener required</span><br><span class="line">                        OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!topic) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;create_topic failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，创建了一个名称为“Pos Demo”，默认主题类型和默认QoS策略的主题，接下来再创建公布者。</p>
<h2 id="4、创建公布者："><a href="#4、创建公布者：" class="headerlink" title="4、创建公布者："></a>4、创建公布者：</h2><p>调用create_publisher()操作创建一个带有默认公布者QoS策略的公布者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DDS::Publisher_var pub =</span><br><span class="line">  participant-&gt;create_publisher(PUBLISHER_QOS_DEFAULT,</span><br><span class="line">                           0,   // No listener required</span><br><span class="line">                           OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">if (!pub) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;create_publisher failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">  return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5、创建数据写者："><a href="#5、创建数据写者：" class="headerlink" title="5、创建数据写者："></a>5、创建数据写者：</h2><p>有了公布者，再调用create_datawriter()操作创建一个数据写者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   DDS::DataWriter_var writer =</span><br><span class="line">     pub-&gt;create_datawriter(topic,</span><br><span class="line">                        DATAWRITER_QOS_DEFAULT,</span><br><span class="line">                        0,   // No listener required</span><br><span class="line">                        OpenDDS::DCPS::DEFAULT_STATUS_MASK);</span><br><span class="line">   if (!writer) &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;create_datawriter failed.&quot; &lt;&lt; std::endl;</span><br><span class="line">     return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建数据写者的时候，使用已经创建好的主题，默认的QoS 策略和空的监听者。然后将数据写者引用转换为PosDataWriter对象引用，方便使用数据写者类中已经定义好的接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Demo::PosDataWriter_var pos_writer = Demo::PosDataWriter::_narrow(writer);</span><br></pre></td></tr></table></figure>

<h2 id="6、公布数据："><a href="#6、公布数据：" class="headerlink" title="6、公布数据："></a>6、公布数据：</h2><p>创建好数据写者，就可以公布数据了，先初始化要公布的对象pos的各个字段，之后调用数据写者的write接口公布数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Demo::Pos pos;</span><br><span class="line">pos.pos_id = 99;</span><br><span class="line">pos. pos_x = 99;</span><br><span class="line">pos. pos_y = 99;</span><br><span class="line">for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">  DDS::ReturnCode_t error = pos_writer-&gt;write(pos, DDS::HANDLE_NIL);</span><br><span class="line">  ++pos.pos_id;</span><br><span class="line">  if (error != DDS::RETCODE_OK) &#123;</span><br><span class="line">    // Log or otherwise handle the error condition</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于每个循环，调用write()操作将样本数据发送给所有注册过该主题的订阅者。</p>
<h2 id="7、等待接收："><a href="#7、等待接收：" class="headerlink" title="7、等待接收："></a>7、等待接收：</h2><p>由于DDS中的数据公布和数据订阅是解耦的，数据不保证一定交付。如果公布端应用程序要求所有公布的数据必须全部交付，需要在公布端调用数据写者的wait_for_acknowledgements()操作，来使公布端应用程序一直等待，直到订阅端接收到所有已经公布的数据。要使wait_for_acknowledgements()操作有效，数据读者必须设置RELIABILITY QoS策略（是缺省值）为RELIABLE。</p>
<p>数据写者调用此操作，并绑定一个timeout值作为等待的超时时间。如下的代码演示了调用wait_for_acknowledgements()阻塞15s等待订阅端接收所有数据的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> DDS::Duration_t shutdown_delay = &#123;15, 0&#125;;</span><br><span class="line"></span><br><span class="line"> DDS::ReturnCode_t result;</span><br><span class="line"> result = writer-&gt;wait_for_acknowledgments(shutdown_delay);</span><br><span class="line"> if( result != DDS::RETCODE_OK) &#123;</span><br><span class="line">  std::cerr &lt;&lt; &quot;Failed while waiting for acknowledgment of &quot;</span><br><span class="line">            &lt;&lt; &quot;data being received by subscriptions, some data &quot;</span><br><span class="line">            &lt;&lt; &quot;may not have been delivered.&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8、实体清理："><a href="#8、实体清理：" class="headerlink" title="8、实体清理："></a>8、实体清理：</h2><p>在公布完数据以后，需要清理与OpenDDS相关联的资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">participant-&gt;delete_contained_entities();</span><br><span class="line">dpf-&gt;delete_participant(participant);</span><br><span class="line">TheServiceParticipant-&gt;shutdown();</span><br></pre></td></tr></table></figure>

<p>调用域参与者的delete_contained_entities()操作删除所有该参与者创建的主题、公布者。一旦执行完该操作，就可以使用域参与者工厂删除域参与者了。</p>
<h2 id="9、示例程序运行："><a href="#9、示例程序运行：" class="headerlink" title="9、示例程序运行："></a>9、示例程序运行：</h2><p>修改完以上代码并编译完成，就可以运行公布端应用程序了，需要先运行DDS的信息仓库，开始中打开一个CMD窗口，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%DDS_ROOT%/bin/DCPSInfoRepo  -ORBEndpoint  iiop://localhost:12345</span><br></pre></td></tr></table></figure>

<p>再次打开一个CMD窗口，cd到Demo目录下，执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publisher -DCPSInfoRepo corbaloc::localhost:12345/DCPSInfoRepo</span><br></pre></td></tr></table></figure>

<p>至此，公布端应用程序就开发完成并运行起来了。</p>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2014/07/10/基于OpenDDS应用程序开发(2)公布端实现/" data-id="ck0rt0asx00091ndx7bpbbvc3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MPC/">MPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/发布数据/">发布数据</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/示例开发/">示例开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-基于OpenDDS应用程序开发(1)IDL定义" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/07/02/基于OpenDDS应用程序开发(1)IDL定义/" class="article-date">
  <time datetime="2014-07-01T16:00:00.000Z" itemprop="datePublished">2014-07-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/02/基于OpenDDS应用程序开发(1)IDL定义/">基于OpenDDS应用程序开发(1)IDL定义</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>连续的三篇博文演示如何基于OpenDDS开发应用程序，将数据从发布端节点发送到订阅端节点，该示例程序由一个发布者发布数据，一个订阅者订阅数据，使用默认的QoS策略和TCP/IP传输方式。</p>
<p>本文是第一篇，主要介绍IDL的定义及编译。</p>
<h2 id="1、IDL定义："><a href="#1、IDL定义：" class="headerlink" title="1、IDL定义："></a>1、IDL定义：</h2><p>DDS中的数据类型需要通过IDL格式定义，OpenDDS使用#pragma关键字定义DDS传输和处理的数据类型。<br>这些数据类型再由tao_idl编译器和OpenDDS_idl编译器进行预编译出来，生成用于网络传输这些数据类型的代码。</p>
<p>下面是一个定义Demo数据类型的IDL文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module Demo &#123;</span><br><span class="line"></span><br><span class="line">#pragma DCPS_DATA_TYPE &quot;Demo::Pos&quot;</span><br><span class="line">#pragma DCPS_DATA_KEY &quot;Demo::Pos.pos_id&quot;</span><br><span class="line"></span><br><span class="line">    struct Pos &#123;</span><br><span class="line">        long pos_id;</span><br><span class="line">        long pos_x;</span><br><span class="line">        long pos_y;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IDL文件使用DCPS_DATA_TYPE定义一个结构体数据类型，IDL语法要求每个类型定义必须以该关键字开头。OpenDDS规定数据类型必须为一个结构体，结构体中可包含标量类型（short、long、float等）、枚举类型、字符串、队列、数组、结构体、以及它们的组合。本例中在demo模块中定义了一个结构体pos。</p>
<p>使用DCPS_DATA_KEY定义一个数据类型的键，一种数据类型可以有0个或多个键，这些键用于区分同一个主题内的不同实体。每个键必须是数值型、枚举型、字符串或者这些类型的typedef。DCPS_DATA_KEY限定了作用域的数据类型以及成员名，成员名标识为该类型的键，多个键由多个DCPS_DATA_KEY指定。在上面的IDL定义中，指定了pos_id作为Demo::Pos的键。每个样本发布时带有一个唯一的pos_id值，这样就可以区分同一主题中的不同实例。由于使用了默认的QoS策略，随后带有相同pos_id值的样本就会替代先前的样本。</p>
<p>其它类型，如结构体、序列和数组不能直接用来做key，但是当结构体的成员或数组中的元素是数值型、枚举型或者字符串型时可以。</p>
<h2 id="2、IDL编译："><a href="#2、IDL编译：" class="headerlink" title="2、IDL编译："></a>2、IDL编译：</h2><p>IDL文件首先需要由tao_idl编译，以生成数据在网络上传输时打包解包的代码，该IDL编译器位于$ACE_ROOT/bin/目录下，运行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tao_idl Demo.idl</span><br></pre></td></tr></table></figure>

<p>该命令为每个IDL文件编译生成6个个文件，这6个文件的文件名均由原IDL文件名开头，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;filename&gt;C.cpp</span><br><span class="line">&lt;filename&gt;C.h</span><br><span class="line">&lt;filename&gt;C.inl</span><br><span class="line">&lt;filename&gt;S.cpp</span><br><span class="line">&lt;filename&gt;S.h</span><br><span class="line">&lt;filename&gt;S.inl</span><br></pre></td></tr></table></figure>

<p>进而，IDL文件还需要由opendds_idl编译，以生成OpenDDS需要打包和解包信息的序列化和键支持代码，及用于数据读者和写者类型支持代码，该IDL编译器位于$DDS_ROOT/bin/目录下，运行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opendds_idl Demo.idl</span><br></pre></td></tr></table></figure>

<p>该命令为每个IDL文件编译生成三个文件，这三个文件的文件名均由原IDL文件名开头，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;filename&gt;TypeSupport.idl</span><br><span class="line">&lt;filename&gt;TypeSupportImpl.h</span><br><span class="line">&lt;filename&gt;TypeSupportImpl.cpp</span><br></pre></td></tr></table></figure>

<p>会生成DemoTypeSupport.idl、DemoTypeSupportImpl.h和DemoTypeSupportImpl.cpp三个文件，生成的IDL文件中包括了PosTypeSupport, PosDataWriter 和PosDataReader的接口定义，这些特定的DDS类型接口将会在稍后注册数据类型，发布数据样本和接收数据样本时使用，而生成的cpp文件实现了这些接口。</p>
<p>生成的IDL文件还需要和原始的IDL一起，由tao_idl编译器再次编译，以便生成相应的接口框架，之后这些生成的实现文件需要和使用Pos类型的OpenDDS应用程序源码一起编译链接。</p>
<p>opendds_idl编译器提供了许多选项参数，用于配置代码生成，这些选项参数将在后续章节详细描述。</p>
<p>通常，我们不需要手动直接调用tao_idl或者opendds_idl来编译IDL文件，可以借助编译工具来完成，如果使用ACE的MPC(MakeProjectCreator)工具，通过继承dcps来配置，该过程将会很简单，如下是使用ACE的MPC工具来实现这个工作的步骤：</p>
<p>首先，需要编写一个Demo.mpc文件，在mpc文件中定义一个idl工程，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">project(*idl): dcps &#123;</span><br><span class="line"></span><br><span class="line">    // This project ensures the common components get built first.</span><br><span class="line">    TypeSupport_Files &#123;</span><br><span class="line">        Demo.idl</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    custom_only = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>idl工程从父工程dcps继承，父工程dcps中定义了类型支持的编译规则，TypeSupport_Files部分告诉MPC，使用opendds_idl编译器从Demo.idl中生成类型支持文件。</p>
<p>编写好mpc文件之后，就可以使用MPC命令来生成C/C++的编译配置文件了，(MPC工具可以生成很多种系统的编译工程，包括Windows的Visual Studio系列，Linux的Makefile等)，这里将Demo.idl文件和Demo.mpc文件放到Demo文件加下，使用如下命令来生成Vs2008的工程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl mwc.pl -type vc9</span><br></pre></td></tr></table></figure>

<p>命令执行完成后，会生成对应的Vs2008工程文件，包括vcproj和sln等，使用Vs2008打开Demo.sln就可以编译前面定义的idl文件，生成DemoC.cpp和DemoTypeSupport.idl等文件了。</p>
<p>关于公布端和订阅端应用程序的开发请参见后续博文。</p>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2014/07/02/基于OpenDDS应用程序开发(1)IDL定义/" data-id="ck0rt0ast00061ndxmx3pioo9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDL定义/">IDL定义</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IDL编译/">IDL编译</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MPC/">MPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/示例开发/">示例开发</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-OpenDDS环境搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/03/06/OpenDDS环境搭建/" class="article-date">
  <time datetime="2014-03-05T16:00:00.000Z" itemprop="datePublished">2014-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/OpenDDS/">OpenDDS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/03/06/OpenDDS环境搭建/">OpenDDS环境搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>以下以Linux系统下的用户DDS为例(关于Windows系统下的搭建过程，跟Linux系统步骤基本一样，请参考文后的评论)，编译OpenDDS源码需要ACE+TAO框架支持，因此需要先编译ACE+TAO的相关库，具体步骤如下：</p>
<h2 id="1、下载ACE和DDS源码："><a href="#1、下载ACE和DDS源码：" class="headerlink" title="1、下载ACE和DDS源码："></a>1、下载ACE和DDS源码：</h2><p>ACE源码：<a href="http://www.theaceorb.com/downloads" target="_blank" rel="noopener">http://www.theaceorb.com/downloads</a><br>DDS源码：<a href="http://download.ociweb.com/OpenDDS" target="_blank" rel="noopener">http://download.ociweb.com/OpenDDS</a></p>
<h2 id="2、拷贝源码包到-WorkSpace目录："><a href="#2、拷贝源码包到-WorkSpace目录：" class="headerlink" title="2、拷贝源码包到/WorkSpace目录："></a>2、拷贝源码包到/WorkSpace目录：</h2><p>切换到root用户，在根目下创建WorkSpace目录，为WorkSpace目录给所有用户添加+w权限(chmod +w)，再切回到原来的DDS用户，将下载的ACE和DDS源码拷贝到WorkSpace目录下并解压，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp ACE+TAO-2.2a.tar.gz /WorkSpace</span><br><span class="line">cp OpenDDS3.5.tar.gz   /WorkSpace</span><br><span class="line">cd /WorkSpace</span><br><span class="line">tar –xzvf ACE+TAO-6.1.0.tar.gz</span><br><span class="line">tar –xzvf OpenDDS3.5.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="3、配置ACE和DDS环境变量："><a href="#3、配置ACE和DDS环境变量：" class="headerlink" title="3、配置ACE和DDS环境变量："></a>3、配置ACE和DDS环境变量：</h2><p>在/home/DDS/.bashrc文件最后加入下面几行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export ACE_ROOT=/WorkSpace/ACE_wrappers</span><br><span class="line">export TAO_ROOT=$ACE_ROOT/TAO</span><br><span class="line">export DDS_ROOT=/WorkSpace/DDS</span><br><span class="line">export PATH=$ACE_ROOT/bin: $DDS_ROOT/bin:$PATH</span><br><span class="line">export LD_LIBRARY_PATH=$ACE_ROOT/lib:$DDS_ROOT/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>使用source /home/DDS/.bashrc命令或者重新登陆终端使环境变量生效</p>
<h2 id="4、准备系统相关配置文件："><a href="#4、准备系统相关配置文件：" class="headerlink" title="4、准备系统相关配置文件："></a>4、准备系统相关配置文件：</h2><p>创建文件/WorkSpace/ACE_wrappers/ace/config.h，写入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;ace/config-linux.h&quot;</span><br></pre></td></tr></table></figure>

<p>创建文件/WorkSpace/ACE_wrappers/include/makeinclude/platform_macros.GNU，写入如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug=0</span><br><span class="line">include $(ACE_ROOT)/include/makeinclude/platform_linux.GNU</span><br></pre></td></tr></table></figure>

<h2 id="5、编译ACE和DDS源码："><a href="#5、编译ACE和DDS源码：" class="headerlink" title="5、编译ACE和DDS源码："></a>5、编译ACE和DDS源码：</h2><p>由于ACE+TAO以及DDS源码中提供了许多测试程序，如果所有源码都编译，将非常耗时，可以只编译ACE+TAO中会被DDS用到的部分，以及DDS的核心部分源码。如此，就需要手动重新生成makefile文件，这里可以借助ACE的MPC工具来完成，先在$DDS_ROOT目录下编写一个DDS_TAO_Simple.mwc文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">workspace &#123;</span><br><span class="line">  $(ACE_ROOT)/ace/ace.mpc</span><br><span class="line">  $(ACE_ROOT)/apps/gperf/src</span><br><span class="line">  $(TAO_ROOT)/TAO_IDL</span><br><span class="line">  $(TAO_ROOT)/tao/tao.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/AnyTypeCode/AnyTypeCode.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/Codeset/Codeset.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/IORTable/IORTable.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/PortableServer/PortableServer.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/IORManipulation/IORManipulation.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/ImR_Client/ImR_Client.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/PI/PI.mpc</span><br><span class="line">  $(TAO_ROOT)/tao/CodecFactory/CodecFactory.mpc</span><br><span class="line">  $(TAO_ROOT)/orbsvcs/orbsvcs/Svc_Utils.mpc</span><br><span class="line">  dds</span><br><span class="line"></span><br><span class="line">  exclude &#123;</span><br><span class="line">    dds/DCPS/QOS_XML_Handler</span><br><span class="line">    DevGuideExamples</span><br><span class="line">    tools</span><br><span class="line">    java</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在$DDS_ROOT目录下使用mwc.pl -type gnuace DDS_TAO_Simple.mwc -include $DDS_ROOT/MPC/config命令就可以生成需要的makefile了。</p>
<p>之后执行(cd $DDS_ROOT; make clean &amp;&amp; make) 1&gt; make-dds.log 2&gt;make-dds-err.log命令完成ACE和DDS的编译，如果编译出错，可以查看log文件的编译过程，待脚本运行完成，整个OpenDDS的开发环境就搭建好了，可以用来进行基于OpenDDS的二次开发了。</p>
<p>如果需要运行DDS的测试程序，cd到测试程序源码目录使用make命令就可以编译执行了。</p>
<p>有关OpenDDS的相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2014/03/06/OpenDDS环境搭建/" data-id="ck0rt0asp00041ndx6kztj8ux" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MPC/">MPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/环境搭建/">环境搭建</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ACE组播通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/04/14/ACE组播通信/" class="article-date">
  <time datetime="2013-04-13T16:00:00.000Z" itemprop="datePublished">2013-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/程序开发/">程序开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/04/14/ACE组播通信/">ACE组播通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>基于ACE的类ACE_SOCK_Dgram_Mcast封装来实现组播发送和接收的简单示例程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">// ACE组播类 CMulticast 实现</span><br><span class="line"></span><br><span class="line">#include &quot;ace/OS_NS_unistd.h&quot;</span><br><span class="line">#include &quot;ace/INET_Addr.h&quot;</span><br><span class="line">#include &quot;ace/Truncate.h&quot;</span><br><span class="line">#include &quot;ace/Log_Msg.h&quot;</span><br><span class="line">#include &quot;ace/os_include/os_netdb.h&quot;</span><br><span class="line">#include &quot;ace/SOCK_Dgram_Mcast.h&quot;</span><br><span class="line"></span><br><span class="line">//  ACE组播 ip</span><br><span class="line">#define DEFAULT_MULTICAST_ADD &quot;239.192.2.3:12345&quot;</span><br><span class="line"></span><br><span class="line">//  ACE组播 TTL</span><br><span class="line">#define MAX_MULTICAST_IP_TTL  5</span><br><span class="line"></span><br><span class="line">class CMulticast</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    CMulticast(const char address[]):</span><br><span class="line">     remote_addr_(u_short(0)), multicast_addr_(address)</span><br><span class="line">    &#123;</span><br><span class="line">       //  ACE组播加入组播组</span><br><span class="line">       if (-1 == mcast_dgram_.join(multicast_addr_))</span><br><span class="line">       &#123;</span><br><span class="line">           ACE_ERROR((LM_ERROR, ACE_TEXT(&quot;%p\n&quot;), &quot;join()&quot;));</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //  ACE组播 设置 TTL</span><br><span class="line">       if (-1 == mcast_dgram_.set_option(IP_MULTICAST_TTL, MAX_MULTICAST_IP_TTL))</span><br><span class="line">       &#123;</span><br><span class="line">           ACE_ERROR((LM_ERROR, ACE_TEXT(&quot;%p\n&quot;), &quot;set_option()&quot;));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    CMulticast(void)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    ssize_t recv_from_multicast_group(char *buf, size_t n)</span><br><span class="line">    &#123;</span><br><span class="line">       ssize_t ret = mcast_dgram_.recv(buf, n, remote_addr_);</span><br><span class="line"></span><br><span class="line">       char hostaddr[MAXHOSTNAME] = &#123;0&#125;;</span><br><span class="line">       remote_addr_.addr_to_string(hostaddr, MAXHOSTNAME);</span><br><span class="line">       cout&lt;&lt;&quot;recve from &quot;&lt;&lt;hostaddr&lt;&lt;&quot; data: &quot;&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">       return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ssize_t send_to_multicast_group(const char *buf, size_t n)</span><br><span class="line">    &#123;</span><br><span class="line">       ssize_t ret = mcast_dgram_.send(buf, n);</span><br><span class="line"></span><br><span class="line">       char hostaddr[MAXHOSTNAME] = &#123;0&#125;;</span><br><span class="line">       multicast_addr_.addr_to_string(hostaddr, MAXHOSTNAME);</span><br><span class="line">       cout&lt;&lt;&quot;send to &quot;&lt;&lt;hostaddr&lt;&lt;&quot; data: &quot;&lt;&lt;buf&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">       return ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~CMulticast(void)</span><br><span class="line">    &#123;</span><br><span class="line">       // ACE组播离开组播组</span><br><span class="line">       if (-1 == mcast_dgram_.leave(multicast_addr_))</span><br><span class="line">       &#123;</span><br><span class="line">           ACE_ERROR((LM_ERROR, ACE_TEXT(&quot;%p\n&quot;), &quot;leave()&quot;));</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">   </span><br><span class="line">    ACE_INET_Addr        multicast_addr_; // 组播组地址</span><br><span class="line">    ACE_INET_Addr        remote_addr_;    // 远端地址</span><br><span class="line">    ACE_SOCK_Dgram_Mcast mcast_dgram_;    //</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  ACE组播 发送端调用示例</span><br><span class="line"></span><br><span class="line">#include &quot;Multicast.h&quot;</span><br><span class="line"></span><br><span class="line">#define data[] = &quot;Hello, world!&quot;</span><br><span class="line"></span><br><span class="line">int ACE_TMAIN(int argc, ACE_TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CMulticast mcast(DEFAULT_MULTICAST_ADD);</span><br><span class="line">    while (-1 != mcast.send_to_multicast_group(data, sizeof(data)/sizeof(char)))</span><br><span class="line">    &#123;</span><br><span class="line">       ACE_OS::sleep(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ACE_ERROR_RETURN((LM_ERROR, ACE_TEXT(&quot;%p\n&quot;), &quot;send()&quot;), 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  ACE组播 接收端调用示例</span><br><span class="line"></span><br><span class="line">#include &quot;Multicast.h&quot;</span><br><span class="line"></span><br><span class="line">int ACE_TMAIN(int argc, ACE_TCHAR *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CMulticast mcast(DEFAULT_MULTICAST_ADD);</span><br><span class="line">    char buf[256] = &#123;0&#125;;</span><br><span class="line">    while (-1 != mcast.recv_from_multicast_group(buf, 255))</span><br><span class="line">    &#123;</span><br><span class="line">       ACE_OS::sleep(2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ACE_ERROR_RETURN((LM_ERROR, ACE_TEXT(&quot;%p\n&quot;), &quot;recv()&quot;), 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有相关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2013/04/14/ACE组播通信/" data-id="ck0rt0as800001ndx8rp00w4x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ACE/">ACE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ace-sock-dgram-mcast/">ace_sock_dgram_mcast</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/组播通信/">组播通信</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-MFC程序添加背景图片的方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2011/04/25/MFC程序添加背景图片的方法/" class="article-date">
  <time datetime="2011-04-24T16:00:00.000Z" itemprop="datePublished">2011-04-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/程序开发/">程序开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2011/04/25/MFC程序添加背景图片的方法/">MFC程序添加背景图片的方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>介绍两种为MFC程序的添加背景图片的方法：资源位图的方式和IPicture控件方式</p>
<h2 id="1、资源位图的方式-背景图片只能是bmp格式，双缓存方式绘制防止闪烁"><a href="#1、资源位图的方式-背景图片只能是bmp格式，双缓存方式绘制防止闪烁" class="headerlink" title="1、资源位图的方式(背景图片只能是bmp格式，双缓存方式绘制防止闪烁)"></a>1、资源位图的方式(背景图片只能是bmp格式，双缓存方式绘制防止闪烁)</h2><p>需要先把以”bmp”为后缀的图片通过插入资源的方式添加到工程中，然后调用下面的函数即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//////////////////////////////////////////////////////////////////////////</span><br><span class="line">//功能：在pDC所在窗口上的DestRect区域内显示资源号bmpID指定的位图</span><br><span class="line">//参数：</span><br><span class="line">//   pDC:目的DC</span><br><span class="line">//   bmpID:目的位图的资源号</span><br><span class="line">//   DestRect:目的区域</span><br><span class="line">//////////////////////////////////////////////////////////////////////////</span><br><span class="line">bool DrawBK(CDC *pDC, UINT bmpID, CRect DestRect)</span><br><span class="line">&#123;</span><br><span class="line">    CBitmap bitmap;</span><br><span class="line">    bitmap.LoadBitmap(bmpID);</span><br><span class="line"></span><br><span class="line">    BITMAP BitMap;</span><br><span class="line">    bitmap.GetBitmap(&amp;BitMap);</span><br><span class="line"></span><br><span class="line">    CDC dcMem;</span><br><span class="line">    dcMem.CreateCompatibleDC(pDC);</span><br><span class="line">    dcMem.SelectObject(&amp;bitmap);</span><br><span class="line"></span><br><span class="line">    pDC-&gt;StretchBlt(DestRect.left,DestRect.top,DestRect.Width(),DestRect.Height(),&amp;dcMem,0,0,BitMap.bmWidth,BitMap.bmHeight,SRCCOPY);</span><br><span class="line"></span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、借用控件IPicture加载图片的方式-背景图片可以是jpg格式"><a href="#2、借用控件IPicture加载图片的方式-背景图片可以是jpg格式" class="headerlink" title="2、借用控件IPicture加载图片的方式(背景图片可以是jpg格式)"></a>2、借用控件IPicture加载图片的方式(背景图片可以是jpg格式)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">//////////////////////////////////////////////////////////////////////////</span><br><span class="line">//功能：在pDC所在窗口上的DestRect区域内显示path指定的图片</span><br><span class="line">//参数：</span><br><span class="line">//   pDC:目的DC</span><br><span class="line">//   path:目的图片的路径</span><br><span class="line">//   DestRect:目的区域</span><br><span class="line">//////////////////////////////////////////////////////////////////////////</span><br><span class="line">bool DrawBK(CDC* pDC,CString path,CRect DestRect)</span><br><span class="line">&#123;</span><br><span class="line">    if(path.IsEmpty())</span><br><span class="line">       return false;</span><br><span class="line"></span><br><span class="line">    IStream *pStm;</span><br><span class="line">    CFileStatus fstatus;</span><br><span class="line">    CFile file;</span><br><span class="line">    LONG cb;</span><br><span class="line"></span><br><span class="line">    if(file.Open(path,CFile::modeRead)&amp;&amp;file.GetStatus(path,fstatus)&amp;&amp;((cb=fstatus.m_size)!=-1))</span><br><span class="line">    &#123;</span><br><span class="line">       HGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE, cb);</span><br><span class="line">       if(hGlobal != NULL)</span><br><span class="line">       &#123;</span><br><span class="line">           LPVOID pvData = GlobalLock(hGlobal);</span><br><span class="line">           if (pvData != NULL)</span><br><span class="line">           &#123;</span><br><span class="line">               file.ReadHuge(pvData, cb);</span><br><span class="line">               GlobalUnlock(hGlobal);</span><br><span class="line">               CreateStreamOnHGlobal(hGlobal, TRUE, &amp;pStm);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">       return false;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    //显示图片</span><br><span class="line">    IPicture *pPic;</span><br><span class="line">    CoInitialize(NULL);</span><br><span class="line"></span><br><span class="line">    if(SUCCEEDED(OleLoadPicture(pStm,fstatus.m_size,TRUE,IID_IPicture,(LPVOID*)&amp;pPic)))</span><br><span class="line">    &#123;</span><br><span class="line">       //得到源图像的大小</span><br><span class="line">       OLE_XSIZE_HIMETRIC hmWidth;</span><br><span class="line">       OLE_YSIZE_HIMETRIC hmHeight;</span><br><span class="line">       pPic-&gt;get_Width(&amp;hmWidth);</span><br><span class="line">       pPic-&gt;get_Height(&amp;hmHeight);</span><br><span class="line"></span><br><span class="line">       //使用render函数显示图片</span><br><span class="line">       if(FAILED(pPic-&gt;Render(*pDC,DestRect.left,DestRect.top,DestRect.Width(),DestRect.Height(),0,hmHeight,hmWidth,-hmHeight,NULL)))</span><br><span class="line">       &#123;</span><br><span class="line">           pPic-&gt;Release();</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       pPic-&gt;Release();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;  </span><br><span class="line">       return false;</span><br><span class="line">    &#125;</span><br><span class="line">    CoUninitialize();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关问题欢迎发送邮件至<a href="mailto:lyingbo@aliyun.com" target="_blank" rel="noopener">lyingbo@aliyun.com</a>一起讨论</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://lyingbo.com/2011/04/25/MFC程序添加背景图片的方法/" data-id="ck0rt0asj00011ndx76rmwkpc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MFC/">MFC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/bmp/">bmp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jpg/">jpg</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/双缓存/">双缓存</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/OpenDDS/">OpenDDS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/程序开发/">程序开发</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACE/">ACE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cluster/">Cluster</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DataNode/">DataNode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hadoop/">Hadoop</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDL定义/">IDL定义</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDL编译/">IDL编译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MFC/">MFC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MPC/">MPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NameNode/">NameNode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenDDS/">OpenDDS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qos/">Qos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ace-sock-dgram-mcast/">ace_sock_dgram_mcast</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bmp/">bmp</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jpg/">jpg</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/双缓存/">双缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/发布数据/">发布数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境搭建/">环境搭建</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/示例开发/">示例开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/策略使用/">策略使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/策略说明/">策略说明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/组播通信/">组播通信</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/订阅数据/">订阅数据</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ACE/" style="font-size: 10px;">ACE</a> <a href="/tags/Cluster/" style="font-size: 10px;">Cluster</a> <a href="/tags/DataNode/" style="font-size: 10px;">DataNode</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Hadoop/" style="font-size: 10px;">Hadoop</a> <a href="/tags/IDL定义/" style="font-size: 10px;">IDL定义</a> <a href="/tags/IDL编译/" style="font-size: 10px;">IDL编译</a> <a href="/tags/MFC/" style="font-size: 10px;">MFC</a> <a href="/tags/MPC/" style="font-size: 16.67px;">MPC</a> <a href="/tags/NameNode/" style="font-size: 10px;">NameNode</a> <a href="/tags/OpenDDS/" style="font-size: 20px;">OpenDDS</a> <a href="/tags/Qos/" style="font-size: 13.33px;">Qos</a> <a href="/tags/ace-sock-dgram-mcast/" style="font-size: 10px;">ace_sock_dgram_mcast</a> <a href="/tags/bmp/" style="font-size: 10px;">bmp</a> <a href="/tags/jpg/" style="font-size: 10px;">jpg</a> <a href="/tags/双缓存/" style="font-size: 10px;">双缓存</a> <a href="/tags/发布数据/" style="font-size: 10px;">发布数据</a> <a href="/tags/环境搭建/" style="font-size: 10px;">环境搭建</a> <a href="/tags/示例开发/" style="font-size: 13.33px;">示例开发</a> <a href="/tags/策略使用/" style="font-size: 13.33px;">策略使用</a> <a href="/tags/策略说明/" style="font-size: 13.33px;">策略说明</a> <a href="/tags/组播通信/" style="font-size: 10px;">组播通信</a> <a href="/tags/订阅数据/" style="font-size: 10px;">订阅数据</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/04/">April 2011</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/14/基于Docker搭建Hadoop集群/">基于Docker搭建Hadoop集群</a>
          </li>
        
          <li>
            <a href="/2016/03/20/OpenDDS之Qos策略(3)/">OpenDDS之Qos策略(3)</a>
          </li>
        
          <li>
            <a href="/2015/11/23/OpenDDS之Qos策略(2)/">OpenDDS之Qos策略(2)</a>
          </li>
        
          <li>
            <a href="/2014/09/16/OpenDDS之Qos策略(1)/">OpenDDS之Qos策略(1)</a>
          </li>
        
          <li>
            <a href="/2014/07/29/基于OpenDDS应用程序开发(3)订阅端实现/">基于OpenDDS应用程序开发(3)订阅端实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 lyingbo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>